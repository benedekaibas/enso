[
  {
    "title": "Type Checker Divergence 1",
    "description": "Code snippet demonstrating type checker divergence: unknown",
    "code": "from typing import Protocol\n\nclass Writer(Protocol):\n    def write(self, data: bytes, mode: str = 'w') -> int: ...\n\nclass FileWriter:\n    def write(self, data: bytes, mode: str = 'a') -> int:  # Different default 'a' vs 'w'\n        return len(data)\n\ndef use_writer(w: Writer) -> None: ...\nuse_writer(FileWriter())  # Checkers disagree on default arg compatibility"
  },
  {
    "title": "Type Checker Divergence 2",
    "description": "Code snippet demonstrating type checker divergence: unknown",
    "code": "from typing import TypeGuard, TypeVar, Dict, Any\nK = TypeVar('K')\nV = TypeVar('V')\n\ndef is_str_dict(val: dict[Any, Any]) -> TypeGuard[dict[str, str]]:\n    return all(isinstance(k, str) and isinstance(v, str) for k, v in val.items())\n\ndef process(data: Dict[object, object]) -> None:\n    if is_str_dict(data):\n        data['key'] = 'value'  # Checkers disagree on key/value type narrowing"
  },
  {
    "title": "Type Checker Divergence 3",
    "description": "Code snippet demonstrating type checker divergence: unknown",
    "code": "from typing import TypedDict\nfrom typing_extensions import NotRequired\n\nclass Parent(TypedDict, total=True):\n    a: int\n    b: NotRequired[str]\n\nclass Child(Parent, total=False):\n    c: float  # Now 'a' is required, 'b' is not, 'c' is not required\n\ndef test(td: Child) -> None:\n    td['a']  # Checkers disagree on required status of 'a' in Child"
  },
  {
    "title": "Type Checker Divergence 4",
    "description": "Code snippet demonstrating type checker divergence: unknown",
    "code": "from typing import Callable, TypeVar, Any\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef debug(func: Callable[P, T]) -> Callable[P, T]:\n    return func\n\nclass Logger:\n    @debug\n    @classmethod\n    def log(cls, message: str) -> None:  # Checkers disagree on decorated classmethod type\n        print(message)\n\nLogger.log(\"test\")  # Some checkers may complain about 'cls' argument"
  },
  {
    "title": "Type Checker Divergence 5",
    "description": "Code snippet demonstrating type checker divergence: unknown",
    "code": "from typing import Generic, TypeVar\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass Builder(ABC, Generic[T]):\n    @abstractmethod\n    def build(self) -> Self: ...\n\nclass IntBuilder(Builder[int]):\n    def build(self) -> Self:\n        return self  # Checkers disagree on return type compatibility"
  },
  {
    "title": "Type Checker Divergence 6",
    "description": "Code snippet demonstrating type checker divergence: unknown",
    "code": "from typing import NewType, List\n\nAccountID = NewType('AccountID', int)\nTransactionID = NewType('TransactionID', int)\n\ndef process_accounts(ids: List[AccountID]) -> None: ...\n\nmixed_list: List[int] = [AccountID(100), 200]  # Contains both AccountID and int\nprocess_accounts(mixed_list)  # Checkers disagree on List[AccountID] vs List[int]"
  },
  {
    "title": "Type Checker Divergence 7",
    "description": "Code snippet demonstrating type checker divergence: unknown",
    "code": "from typing import overload, Literal, Union\n\n@overload\ndef convert(val: Literal[1]) -> str: ...\n@overload\ndef convert(val: Literal[2]) -> int: ...\n@overload\ndef convert(val: int) -> float: ...\n\ndef convert(val: int) -> Union[str, int, float]:\n    if val == 1:\n        return \"one\"\n    elif val == 2:\n        return 2\n    return float(val)\n\nresult = convert(1)  # Checkers disagree: str vs Union[...]"
  },
  {
    "title": "Type Checker Divergence 8",
    "description": "Code snippet demonstrating type checker divergence: unknown",
    "code": "from typing import Final\n\nclass Base:\n    @property\n    def value(self) -> int:\n        return 42\n\nclass Derived(Base):\n    value: Final[int] = 100  # Checkers disagree on overriding property with attribute"
  },
  {
    "title": "Type Checker Divergence 9",
    "description": "Code snippet demonstrating type checker divergence: unknown",
    "code": "from typing import TypeVar, Generic\n\nclass Box(Generic[T]):\n    pass\n\nT2 = TypeVar('T2', bound=Box[float])\n\ndef unpack(box: T2) -> None: ...\n\nfloat_box: Box[float] = Box()\nunpack(float_box)  # Checkers disagree if T2 bound is properly enforced"
  },
  {
    "title": "Type Checker Divergence 10",
    "description": "Code snippet demonstrating type checker divergence: unknown",
    "code": "from typing import Protocol\n\nclass Handler(Protocol):\n    def __call__(self, *, timeout: int) -> str: ...\n\ndef handle(timeout: int) -> str:\n    return str(timeout)\n\nhandler: Handler = handle  # Checkers disagree on positional vs keyword"
  },
  {
    "title": "Type Checker Divergence 11",
    "description": "Code snippet demonstrating type checker divergence: protocol-default-args-writer",
    "code": "# id: protocol-default-args-writer\n# EXPECTED:\n#   mypy: No error\n#   pyright: Error\n#   pyre: Error\n#   zuban: No error\n# REASON: Protocol parameter defaults aren't checked by all type checkers\nfrom typing import Protocol\n\nclass Writer(Protocol):\n    def write(self, data: bytes, mode: str = 'w') -> int: ...\n\nclass BufferedWriter:\n    def write(self, data: bytes, mode: str = 'wb') -> int:  # Different default\n        return len(data)\n\ndef use_writer(w: Writer) -> None: ...\n\nif __name__ == \"__main__\":\n    use_writer(BufferedWriter())  # Divergence in default arg compatibility"
  },
  {
    "title": "Type Checker Divergence 12",
    "description": "Code snippet demonstrating type checker divergence: typeguard-tuple-narrow",
    "code": "# id: typeguard-tuple-narrow\n# EXPECTED:\n#   mypy: Item access error\n#   pyright: No error\n#   pyre: Item access error\n#   zuban: No error\n# REASON: TypeGuard narrowing for tuples handled differently\nfrom typing import TypeGuard, Union\n\ndef is_int_tuple(val: tuple[Union[int, str], ...]) -> TypeGuard[tuple[int, ...]]:\n    return all(isinstance(x, int) for x in val)\n\ndef process(data: tuple[Union[int, str], ...]) -> None:\n    if is_int_tuple(data):\n        data[0] + 1  # Checkers disagree on element type narrowing\n\nif __name__ == \"__main__\":\n    process((1, \"two\"))"
  },
  {
    "title": "Type Checker Divergence 13",
    "description": "Code snippet demonstrating type checker divergence: typeddict-mixed-required",
    "code": "# id: typeddict-mixed-required\n# EXPECTED:\n#   mypy: 'name' is required\n#   pyright: 'name' is optional\n#   pyre: 'name' is required\n#   zuban: 'name' is optional\n# REASON: Total inheritance semantics differ across checkers\nfrom typing import TypedDict\nfrom typing_extensions import Required, NotRequired\n\nclass Base(TypedDict, total=True):\n    id: int\n\nclass User(Base, total=False):\n    name: Required[str]\n    age: NotRequired[int]\n\ndef handle_user(u: User) -> None:\n    u['id']  # All agree required\n    u['name']  # Checkers disagree on required status\n\nif __name__ == \"__main__\":\n    handle_user({'id': 1, 'name': 'Alice'})"
  },
  {
    "title": "Type Checker Divergence 14",
    "description": "Code snippet demonstrating type checker divergence: decorator-classmethod-return",
    "code": "# id: decorator-classmethod-return\n# EXPECTED:\n#   mypy: Incompatible return type\n#   pyright: No error\n#   pyre: Incompatible return type\n#   zuban: No error\n# REASON: Decorator chain preservation for classmethod returns\nfrom typing import Callable, TypeVar, Any\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef validate(func: Callable[P, T]) -> Callable[P, T]:\n    return func\n\nclass Factory:\n    @validate\n    @classmethod\n    def create(cls, value: int) -> \"Factory\":  # Checkers disagree on return type\n        return cls()\n\nif __name__ == \"__main__\":\n    Factory.create(42)"
  },
  {
    "title": "Type Checker Divergence 15",
    "description": "Code snippet demonstrating type checker divergence: self-generic-inheritance",
    "code": "# id: self-generic-inheritance\n# EXPECTED:\n#   mypy: Return type incompatible\n#   pyright: No error\n#   pyre: Incompatible return type\n#   zuban: No error\n# REASON: Self type in generic base class handling\nfrom typing import Generic, TypeVar\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass Template(ABC, Generic[T]):\n    @abstractmethod\n    def clone(self) -> Self: ...\n\nclass StringTemplate(Template[str]):\n    def clone(self) -> Self:\n        return self  # Checkers disagree on Self compatibility\n\nif __name__ == \"__main__\":\n    StringTemplate().clone()"
  },
  {
    "title": "Type Checker Divergence 16",
    "description": "Code snippet demonstrating type checker divergence: newtype-list-covariance",
    "code": "# id: newtype-list-covariance\n# EXPECTED:\n#   mypy: List invariant error\n#   pyright: No error\n#   pyre: List invariant error\n#   zuban: No error\n# REASON: NewType list covariance handling differs\nfrom typing import NewType, List\n\nHandle = NewType('Handle', int)\nPort = NewType('Port', int)\n\ndef open_connections(handles: List[Handle]) -> None: ...\n\nif __name__ == \"__main__\":\n    ports: List[Port] = [Port(80), Port(443)]\n    open_connections(ports)  # Checkers disagree on NewType list compatibility"
  },
  {
    "title": "Type Checker Divergence 17",
    "description": "Code snippet demonstrating type checker divergence: overload-literal-int",
    "code": "# id: overload-literal-int\n# EXPECTED:\n#   mypy: Incompatible return type\n#   pyright: Literal type preserved\n#   pyre: Incompatible return type\n#   zuban: Literal type preserved\n# REASON: Literal type narrowing in overload resolution\nfrom typing import overload, Literal, Union\n\n@overload\ndef parse_int(value: Literal[\"0\"]) -> Literal[0]: ...\n@overload\ndef parse_int(value: str) -> Union[int, None]: ...\n\ndef parse_int(value: str) -> Union[int, None]:\n    try: return int(value)\n    except: return None\n\nresult = parse_int(\"0\")  # Checkers disagree on Literal[0] vs int\n\nif __name__ == \"__main__\":\n    print(result)"
  },
  {
    "title": "Type Checker Divergence 18",
    "description": "Code snippet demonstrating type checker divergence: final-method-override",
    "code": "# id: final-method-override\n# EXPECTED:\n#   mypy: Cannot override final method\n#   pyright: No error\n#   pyre: Cannot override final method\n#   zuban: No error\n# REASON: Final method override checking strictness\nfrom typing import final\n\nclass Base:\n    @final\n    def critical(self) -> None: ...\n\nclass Derived(Base):\n    def critical(self) -> None:  # Checkers disagree on final enforcement\n        print(\"Overridden\")\n\nif __name__ == \"__main__\":\n    Derived().critical()"
  },
  {
    "title": "Type Checker Divergence 19",
    "description": "Code snippet demonstrating type checker divergence: double-bound-generic",
    "code": "# id: double-bound-generic\n# EXPECTED:\n#   mypy: Type argument error\n#   pyright: No error\n#   pyre: Type argument error\n#   zuban: No error\n# REASON: Nested generic bounds checking\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T', bound=float)\nU = TypeVar('U', bound=Generic[T])\n\nclass Container(Generic[T]): ...\n\ndef process(container: U) -> None: ...\n\nif __name__ == \"__main__\":\n    process(Container[float]())  # Checkers disagree on double-bound compatibility"
  },
  {
    "title": "Type Checker Divergence 20",
    "description": "Code snippet demonstrating type checker divergence: protocol-keyword-args",
    "code": "# id: protocol-keyword-args\n# EXPECTED:\n#   mypy: Incompatible types\n#   pyright: No error\n#   pyre: Incompatible types\n#   zuban: No error\n# REASON: Positional vs keyword argument protocol matching\nfrom typing import Protocol\n\nclass Formatter(Protocol):\n    def format(self, *, text: str, width: int) -> str: ...\n\ndef simple_format(text: str, width: int) -> str:\n    return f\"{text:{width}}\"\n\nhandler: Formatter = simple_format  # Checkers disagree on positional params\n\nif __name__ == \"__main__\":\n    handler.format(text=\"test\", width=10)"
  }
]