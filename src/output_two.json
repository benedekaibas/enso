[
  {
    "title": "Type Checker Divergence 1",
    "description": "Code snippet demonstrating type checker divergence: protocol-defaults-case1",
    "code": "# id: protocol-defaults-case1\n# EXPECTED:\n#   mypy: Accepts FileReader as Reader (default arg value differs is OK)\n#   pyright: Reports error (default argument value doesn't match exactly)\n#   pyre: Accepts FileReader as Reader (allows default arg differences)\n#   zuban: Error (default arg clash)\n# REASON: Not all type checkers agree whether default argument values must be equal for protocol compatibility.\n\nfrom typing import Protocol\n\nclass Writer(Protocol):\n    def write(self, data: bytes, flush: bool = True) -> int: ...\n\nclass FileWriter:\n    def write(self, data: bytes, flush: bool = False) -> int:  # Different default for flush\n        return len(data)\n\ndef use_writer(w: Writer) -> None:\n    print(w.write(b\"hi\"))\n\nif __name__ == \"__main__\":\n    use_writer(FileWriter())  # Divergence on protocol implementation due to default args"
  },
  {
    "title": "Type Checker Divergence 2",
    "description": "Code snippet demonstrating type checker divergence: typeguard-generic-case1",
    "code": "# id: typeguard-generic-case1\n# EXPECTED:\n#   mypy: Narrows data to list[int] inside block; append(int) is OK\n#   pyright: Does NOT narrow data (TypeGuard loses info) \n#   pyre: Narrows data but loses generic; error on append\n#   zuban: Fails to narrow list[object] to list[int]\n# REASON: Some type checkers can't apply TypeGuard with generics, especially when narrowing container element types.\n\nfrom typing import TypeGuard, TypeVar, List\nT = TypeVar(\"T\")\n\ndef is_list_of_type(xs: list[object], typ: type[T]) -> TypeGuard[list[T]]:\n    return all(isinstance(x, typ) for x in xs)\n\ndef run(xs: List[object]) -> None:\n    if is_list_of_type(xs, int):\n        xs.append(3)  # Do checkers allow append(int) now?\n\nif __name__ == \"__main__\":\n    run([1, 2, 3])"
  },
  {
    "title": "Type Checker Divergence 3",
    "description": "Code snippet demonstrating type checker divergence: typeddict-mixed-total-case1",
    "code": "# id: typeddict-mixed-total-case1\n# EXPECTED:\n#   mypy: child.get('foo') is Optional with total=False\n#   pyright: child.get('foo') as str, not Optional\n#   pyre: Treats as required, not Optional\n#   zuban: Required/NotRequired mixing not supported, error or wrong optionality\n# REASON: Most type checkers disagree on how `Required` and `NotRequired` interact inside a partially total TypedDict.\n\nfrom typing import TypedDict\nfrom typing_extensions import Required, NotRequired\n\nclass TDBase(TypedDict, total=False):\n    foo: int\n\nclass TDChild(TDBase):\n    bar: Required[str]\n    baz: NotRequired[float]\n\ndef show(td: TDChild) -> None:\n    print(td.get('foo'))  # Is this Optional[int], int, or error?\n\nif __name__ == \"__main__\":\n    show({'bar': 'x', 'foo': 42})"
  },
  {
    "title": "Type Checker Divergence 4",
    "description": "Code snippet demonstrating type checker divergence: paramspec-classmethod-decorator-case1",
    "code": "# id: paramspec-classmethod-decorator-case1\n# EXPECTED:\n#   mypy: Accepts, signature preserved, no error\n#   pyright: Reports error, decorator breaks @classmethod signature\n#   pyre: Accepts (but sometimes ignores decorator stack), no error\n#   zuban: Error, cannot compose ParamSpec and @classmethod\n# REASON: Not all type checkers understand stacked decorators (ParamSpec then @classmethod) and can infer proper classmethod signature.\n\nfrom typing import Callable, TypeVar\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec(\"P\")\nR = TypeVar(\"R\")\n\ndef passthru(f: Callable[P, R]) -> Callable[P, R]:\n    return f\n\nclass Build:\n    @passthru\n    @classmethod\n    def construct(cls, thing: str) -> \"Build\":\n        return cls()\n\nif __name__ == \"__main__\":\n    print(Build.construct(\"item\"))"
  },
  {
    "title": "Type Checker Divergence 5",
    "description": "Code snippet demonstrating type checker divergence: self-in-generics-case1",
    "code": "# id: self-in-generics-case1\n# EXPECTED:\n#   mypy: Accepts Self, returns correct instance\n#   pyright: Error, Self not allowed in generic ABC context\n#   pyre: Error, Self in generics not supported\n#   zuban: Error, Self cannot be used in generics\n# REASON: `Self` is not universally supported in abstract generic classes, checkers disagree on specification usage.\n\nfrom typing import Generic, TypeVar\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nT = TypeVar(\"T\")\n\nclass Maker(ABC, Generic[T]):\n    @abstractmethod\n    def make(self) -> Self:\n        ...\n\nclass TextMaker(Maker[str]):\n    def make(self) -> Self:\n        return self\n\nif __name__ == \"__main__\":\n    m = TextMaker()\n    m2 = m.make()\n    print(m is m2)"
  },
  {
    "title": "Type Checker Divergence 6",
    "description": "Code snippet demonstrating type checker divergence: newtype-list-covariance-case1",
    "code": "# id: newtype-list-covariance-case1\n# EXPECTED:\n#   mypy: error on process_user_ids(int_list) call\n#   pyright: allows process_user_ids(int_list)\n#   pyre: error, List[int] vs List[UserId] incompatible\n#   zuban: allows List[int] as List[UserId] (covariant)\n# REASON: NewType breaks nominal typing, but not all type checkers respect NewType as strictly as intended, especially in generics.\n\nfrom typing import NewType, List\n\nCustomerId = NewType('CustomerId', int)\nOrderId = NewType('OrderId', int)\n\ndef handle_customers(ids: List[CustomerId]) -> None:\n    for cid in ids:\n        print(cid)\n\nif __name__ == \"__main__\":\n    handle_customers([CustomerId(7), CustomerId(8)])\n    handle_customers([1, 2])  # Divergence: Should this be OK?"
  },
  {
    "title": "Type Checker Divergence 7",
    "description": "Code snippet demonstrating type checker divergence: overload-literal-discrim-case1",
    "code": "# id: overload-literal-discrim-case1\n# EXPECTED:\n#   mypy: result1 inferred as bool, result2 as bool\n#   pyright: result1 and result2 as Union[bool, str]\n#   pyre: result1 Union[bool, str], result2 Union[bool, str]\n#   zuban: result1 as bool, result2 as Union[bool, str]\n# REASON: Literal narrowing in overloads is inconsistently applied across type checkers.\n\nfrom typing import overload, Literal, Union\n\n@overload\ndef flag(v: Literal[\"yes\"]) -> bool: ...\n@overload\ndef flag(v: Literal[\"no\"]) -> bool: ...\n@overload\ndef flag(v: str) -> str: ...\n\ndef flag(v: str) -> Union[bool, str]:\n    if v == \"yes\": return True\n    if v == \"no\": return False\n    return v\n\nresp1 = flag(\"yes\")\nresp2 = flag(\"no\")\n\nif __name__ == \"__main__\":\n    print(resp1, resp2)"
  },
  {
    "title": "Type Checker Divergence 8",
    "description": "Code snippet demonstrating type checker divergence: final-property-override-case1",
    "code": "# id: final-property-override-case1\n# EXPECTED:\n#   mypy: Error, cannot override Final attribute, including with @property\n#   pyright: OK, property override allowed\n#   pyre: Error, Final prevents property override\n#   zuban: Allows property override of Final\n# REASON: Not all checkers treat Final as blocking property overrides.\n\nfrom typing import Final\n\nclass Parent:\n    val: Final[int] = 100\n\nclass Child(Parent):\n    @property\n    def val(self) -> int:  # Should this be legal?\n        return 200\n\nif __name__ == \"__main__\":\n    print(Child().val)"
  },
  {
    "title": "Type Checker Divergence 9",
    "description": "Code snippet demonstrating type checker divergence: typevar-double-bound-case1",
    "code": "# id: typevar-double-bound-case1\n# EXPECTED:\n#   mypy: Allows double-bound TypeVar for generic container\n#   pyright: Does NOT allow double-bound TypeVar\n#   pyre: Error, double-bound TypeVar unsupported\n#   zuban: Error, rejects compound bounds\n# REASON: Multiple bounds (e.g. T bound to Container[Animal]) are implemented inconsistently in type checkers.\n\nfrom typing import TypeVar, Generic\n\nclass Base: ...\nclass Sub(Base): ...\nclass Other(Base): ...\n\nV = TypeVar('V', bound=Base)\n\nclass Thing(Generic[V]): ...\n\nW = TypeVar('W', bound=Thing[Base])  # Compounded bound\n\ndef process(t: W) -> None:\n    print(type(t))\n\nif __name__ == \"__main__\":\n    thing = Thing[Sub]()\n    process(thing)"
  },
  {
    "title": "Type Checker Divergence 10",
    "description": "Code snippet demonstrating type checker divergence: protocol-kwargs-positional-case1",
    "code": "# id: protocol-kwargs-positional-case1\n# EXPECTED:\n#   mypy: Accepts simple_func as KwargProtocol\n#   pyright: Error, positional/keyword mismatch\n#   pyre: Error, signature mismatch\n#   zuban: Accepts, ignores positional vs keyword distinction\n# REASON: Protocol matching is sensitive to call signatures (keyword-only), which is not consistently enforced by all checkers.\n\nfrom typing import Protocol, Callable\n\nclass FuncProtocol(Protocol):\n    def __call__(self, *, name: str, level: int) -> str: ...\n\ndef simple_func(name: str, level: int) -> str:  # Positional, not keyword-only params\n    return f\"{name}-{level}\"\n\ndef run(handler: FuncProtocol) -> None:\n    print(handler(name=\"Ann\", level=3))\n\nif __name__ == \"__main__\":\n    run(simple_func)  # Should this be a type error?"
  }
]
