[
  {
    "id": "Generics/Self Type-example",
    "category": "Generics/Self Type",
    "code": "# id: generics-self-type/generic-bound-self-annotation\n# EXPECTED:\n#   mypy: No error\n#   pyrefly: Error: Argument of type \"SolutionArray[Liquid]\" is not assignable to parameter of type \"SolutionArray[Solid]\" in \"solid_method\"\n#   ty: Error: Incompatible self type\n#   zuban: Error: Incompatible parameter type\n# REASON: mypy doesn't validate generic type parameter in self annotations at call sites, while others enforce strict type binding\n\nfrom typing import Generic, TypeVar\nfrom typing_extensions import Self\n\nT = TypeVar('T', bound='Phase')\n\nclass Phase: pass\nclass Liquid(Phase): pass\nclass Solid(Phase): pass\n\nclass SolutionArray(Generic[T]):\n    def with_phase(self, phase: T) -> Self:\n        return self\n    \n    # Method only valid for Solid-phase solutions\n    def solid_method(self: 'SolutionArray[Solid]') -> None:\n        print(\"Performing solid-phase operation\")\n\ndef main():\n    liquid_solution = SolutionArray[Liquid]()\n    liquid_solution.with_phase(Liquid()).solid_method()  # Invalid but mypy allows\n\nif __name__ == \"__main__\":\n    main()  # Runs and prints despite type safety issue",
    "expected_behaviors": {
      "mypy": "Accepts invalid Self type binding in generic parameter (fails to enforce phase-specific method constraints)",
      "pyrefly": "Rejects invalid Self type binding (similar to pyright's strict generic type enforcement)",
      "ty": "Likely rejects based on stricter generic variance rules",
      "zuban": "Rejects with Pyre-style generic type parameter enforcement"
    },
    "reason": "When using Self type annotation with a generic class parameter to restrict methods to specific subtypes, mypy fails to properly validate the generic type binding at method call sites. This allows calling phase-specific methods on incompatible SolutionArray instances. Other checkers like pyright/pyrefly and pyre/zuban enforce the generic type parameter constraints more strictly, correctly flagging invalid usages.",
    "issue_references": [
      "https://github.com/Cantera/cantera/issues/2051"
    ]
  },
  {
    "id": "NewType-example",
    "category": "NewType",
    "code": "# id: newtype-invariance-enforcement\n# EXPECTED:\n#   mypy: error: Argument 1 to \"require_user_id\" has incompatible type \"ChannelId\"; expected \"UserId\"\n#   pyrefly: error: Argument of type \"ChannelId\" cannot be assigned to parameter \"uid\" of type \"UserId\"\n#   ty: No error (allows mixing NewTypes)\n#   zuban: error: Incompatible parameter type [Pyre]\n# REASON: Mypy/pyright enforce NewType invariance strictly while other checkers may not. NewTypes are meant to prevent accidental mixing of primitive-based types.\n\nfrom typing import NewType\n\n# Define two distinct NewTypes based on int\nUserId = NewType('UserId', int)\nChannelId = NewType('ChannelId', int)\n\ndef require_user_id(uid: UserId) -> None:\n    print(f\"Processing user ID: {uid}\")\n\nif __name__ == \"__main__\":\n    user = UserId(42)\n    channel = ChannelId(9001)\n\n    require_user_id(user)  # Valid for all checkers\n    \n    # Type checkers should diverge here on ChannelId -> UserId assignment\n    require_user_id(channel)  # type: ignore[arg-type]",
    "expected_behaviors": {
      "mypy": "rejects incorrect NewType assignments (enforces invariance)",
      "pyrefly": "likely rejects (aligned with pyright's strict NewType handling)",
      "ty": "unknown, may accept due to weaker invariance checks",
      "zuban": "likely rejects (similar to pyre's invariant enforcement)"
    },
    "reason": "The issue highlights a scenario where distinct NewTypes (e.g., UserId and ChannelId) are used to prevent invalid assignments. Mypy and pyright-based checkers enforce NewType invariance, rejecting cross-type assignments (e.g., passing a ChannelId where UserId is required). Other checkers like 'ty' might not enforce this strictly, allowing unsafe mixing of NewTypes. This divergence stems from differences in how checkers implement NewType invariance rules.",
    "issue_references": [
      "https://github.com/DisnakeDev/disnake/issues/1149"
    ]
  }
]
