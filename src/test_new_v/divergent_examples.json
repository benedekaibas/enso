[
  {
    "id": "zubanls-zuban-154-original",
    "source_issue": "https://github.com/zubanls/zuban/issues/154",
    "source_issue_tracker": "https://github.com/zubanls/zuban/issues",
    "original_code": "import enum\nfrom typing import TYPE_CHECKING, Self, final\n\n\n@final\nclass MyEnum(enum.StrEnum):\n    FOO = \"foo\"\n\n    @classmethod\n    def build(cls) -> Self:\n        if TYPE_CHECKING:\n            reveal_type(cls.FOO)\n            reveal_type(MyEnum.FOO)\n        print(type(cls.FOO))\n        return cls.FOO\n\n    @classmethod\n    def build2(cls) -> Self:\n        if TYPE_CHECKING:\n            reveal_type(cls.FOO)\n            reveal_type(MyEnum.FOO)\n        print(type(cls.FOO))\n        return MyEnum.FOO\n\n    @classmethod\n    def cast(cls, value: str) -> Self:\n        print(type(cls(value)))\n        return cls(value)\n\n\nprint(MyEnum(\"foo\"))\nprint(MyEnum.build())",
    "tweaked_code": "import enum\nfrom typing import TYPE_CHECKING, Self, final\n\n\n@final\nclass MyEnum(enum.StrEnum):\n    FOO = \"foo\"\n\n    @classmethod\n    def build(cls) -> Self:\n        if TYPE_CHECKING:\n            reveal_type(cls.FOO)\n            reveal_type(MyEnum.FOO)\n        print(type(cls.FOO))\n        return cls.FOO\n\n    @classmethod\n    def build2(cls) -> Self:\n        if TYPE_CHECKING:\n            reveal_type(cls.FOO)\n            reveal_type(MyEnum.FOO)\n        print(type(cls.FOO))\n        return MyEnum.FOO\n\n    @classmethod\n    def cast(cls, value: str) -> Self:\n        print(type(cls(value)))\n        return cls(value)\n\n\nprint(MyEnum(\"foo\"))\nprint(MyEnum.build())",
    "tweak_description": "Original code from issue (no tweaking needed)",
    "checker_outputs": {
      "mypy": "/tmp/tmpq19ehs39.py:2: error: Module \"typing\" has no attribute \"Self\"  [attr-defined]\n/tmp/tmpq19ehs39.py:2: note: Use `from typing_extensions import Self` instead\n/tmp/tmpq19ehs39.py:2: note: See https://mypy.readthedocs.io/en/stable/runtime_troubles.html#using-new-additions-to-the-typing-module\n/tmp/tmpq19ehs39.py:6: error: Name \"enum.StrEnum\" is not defined  [name-defined]\n/tmp/tmpq19ehs39.py:12: note: Revealed type is \"builtins.str\"\n/tmp/tmpq19ehs39.py:13: note: Revealed type is \"builtins.str\"\n/tmp/tmpq19ehs39.py:20: note: Revealed type is \"builtins.str\"\n/tmp/tmpq19ehs39.py:21: note: Revealed type is \"builtins.str\"\nFound 2 errors in 1 file (checked 1 source file)\n",
      "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> /tmp/tmpbmullp1w.py:12:13\n   |\n12 |             reveal_type(cls.FOO)\n   |             ^^^^^^^^^^^\n   |\n INFO revealed type: Literal[MyEnum.FOO] [reveal-type]\n  --> /tmp/tmpbmullp1w.py:12:24\n   |\n12 |             reveal_type(cls.FOO)\n   |                        ---------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> /tmp/tmpbmullp1w.py:13:13\n   |\n13 |             reveal_type(MyEnum.FOO)\n   |             ^^^^^^^^^^^\n   |\n INFO revealed type: Literal[MyEnum.FOO] [reveal-type]\n  --> /tmp/tmpbmullp1w.py:13:24\n   |\n13 |             reveal_type(MyEnum.FOO)\n   |                        ------------\n   |\nERROR Returned type `Literal[MyEnum.FOO]` is not assignable to declared return type `Self@MyEnum` [bad-return]\n  --> /tmp/tmpbmullp1w.py:15:16\n   |\n15 |         return cls.FOO\n   |                ^^^^^^^\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> /tmp/tmpbmullp1w.py:20:13\n   |\n20 |             reveal_type(cls.FOO)\n   |             ^^^^^^^^^^^\n   |\n INFO revealed type: Literal[MyEnum.FOO] [reveal-type]\n  --> /tmp/tmpbmullp1w.py:20:24\n   |\n20 |             reveal_type(cls.FOO)\n   |                        ---------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> /tmp/tmpbmullp1w.py:21:13\n   |\n21 |             reveal_type(MyEnum.FOO)\n   |             ^^^^^^^^^^^\n   |\n INFO revealed type: Literal[MyEnum.FOO] [reveal-type]\n  --> /tmp/tmpbmullp1w.py:21:24\n   |\n21 |             reveal_type(MyEnum.FOO)\n   |                        ------------\n   |\nERROR Returned type `Literal[MyEnum.FOO]` is not assignable to declared return type `Self@MyEnum` [bad-return]\n  --> /tmp/tmpbmullp1w.py:23:16\n   |\n23 |         return MyEnum.FOO\n   |                ^^^^^^^^^^\n   |\n INFO 6 errors\n",
      "ty": "error[unresolved-import]: Module `typing` has no member `Self`\n --> /tmp/tmpa35f233r.py:2:35\n  |\n1 | import enum\n2 | from typing import TYPE_CHECKING, Self, final\n  |                                   ^^^^\n  |\ninfo: rule `unresolved-import` is enabled by default\n\nerror[unresolved-attribute]: Type `<module 'enum'>` has no attribute `StrEnum`\n --> /tmp/tmpa35f233r.py:6:14\n  |\n5 | @final\n6 | class MyEnum(enum.StrEnum):\n  |              ^^^^^^^^^^^^\n7 |     FOO = \"foo\"\n  |\ninfo: Python 3.9 was assumed when accessing `StrEnum`\n --> /home/benedek-kaibas/Documents/pytifex/pyproject.toml:6:19\n  |\n4 | description = \"All the required packages you need to be able to run pytifex.\"\n5 | readme = \"README.md\"\n6 | requires-python = \">=3.9\"\n  |                   ^^^^^^^ Python 3.9 assumed due to this configuration setting\n7 | license = {text = \"MIT\"}\n8 | authors = [\n  |\ninfo: rule `unresolved-attribute` is enabled by default\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> /tmp/tmpa35f233r.py:12:13\n   |\n10 |     def build(cls) -> Self:\n11 |         if TYPE_CHECKING:\n12 |             reveal_type(cls.FOO)\n   |             ^^^^^^^^^^^\n13 |             reveal_type(MyEnum.FOO)\n14 |         print(type(cls.FOO))\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> /tmp/tmpa35f233r.py:12:25\n   |\n10 |     def build(cls) -> Self:\n11 |         if TYPE_CHECKING:\n12 |             reveal_type(cls.FOO)\n   |                         ^^^^^^^ `Unknown`\n13 |             reveal_type(MyEnum.FOO)\n14 |         print(type(cls.FOO))\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> /tmp/tmpa35f233r.py:13:13\n   |\n11 |         if TYPE_CHECKING:\n12 |             reveal_type(cls.FOO)\n13 |             reveal_type(MyEnum.FOO)\n   |             ^^^^^^^^^^^\n14 |         print(type(cls.FOO))\n15 |         return cls.FOO\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> /tmp/tmpa35f233r.py:13:25\n   |\n11 |         if TYPE_CHECKING:\n12 |             reveal_type(cls.FOO)\n13 |             reveal_type(MyEnum.FOO)\n   |                         ^^^^^^^^^^ `Unknown | Literal[\"foo\"]`\n14 |         print(type(cls.FOO))\n15 |         return cls.FOO\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> /tmp/tmpa35f233r.py:20:13\n   |\n18 |     def build2(cls) -> Self:\n19 |         if TYPE_CHECKING:\n20 |             reveal_type(cls.FOO)\n   |             ^^^^^^^^^^^\n21 |             reveal_type(MyEnum.FOO)\n22 |         print(type(cls.FOO))\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> /tmp/tmpa35f233r.py:20:25\n   |\n18 |     def build2(cls) -> Self:\n19 |         if TYPE_CHECKING:\n20 |             reveal_type(cls.FOO)\n   |                         ^^^^^^^ `Unknown`\n21 |             reveal_type(MyEnum.FOO)\n22 |         print(type(cls.FOO))\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> /tmp/tmpa35f233r.py:21:13\n   |\n19 |         if TYPE_CHECKING:\n20 |             reveal_type(cls.FOO)\n21 |             reveal_type(MyEnum.FOO)\n   |             ^^^^^^^^^^^\n22 |         print(type(cls.FOO))\n23 |         return MyEnum.FOO\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> /tmp/tmpa35f233r.py:21:25\n   |\n19 |         if TYPE_CHECKING:\n20 |             reveal_type(cls.FOO)\n21 |             reveal_type(MyEnum.FOO)\n   |                         ^^^^^^^^^^ `Unknown | Literal[\"foo\"]`\n22 |         print(type(cls.FOO))\n23 |         return MyEnum.FOO\n   |\n\nFound 10 diagnostics\n",
      "zuban": "No Python files found to check for /tmp/tmpfdpfvfn0.py\n"
    },
    "checker_classifications": {
      "mypy": "ERROR",
      "pyrefly": "ERROR",
      "ty": "ERROR",
      "zuban": "CLEAN"
    },
    "analysis": "DIVERGENCE: ['mypy', 'pyrefly', 'ty'] error, ['zuban'] pass",
    "rounds": 0
  },
  {
    "id": "zubanls-zuban-156",
    "source_issue": "https://github.com/zubanls/zuban/issues/156",
    "source_issue_tracker": "https://github.com/zubanls/zuban/issues",
    "original_code": "test_typing.py:141: error: Expression is of type \n\"Addition[Literal[False], IntegerNamedSymbol, int]\"\n, not \n\"Addition[Literal[False], IntegerNamedSymbol, int]\"  [misc]",
    "tweaked_code": "from typing import Literal, Protocol\n\nclass Addition(Protocol):\n    def operation(self) -> Literal[False]:\n        pass\n\nclass IntegerNamedSymbol:\n    pass\n\ndef process(addition: Addition, symbol: IntegerNamedSymbol, value: int) -> Addition:\n    return addition  # Added return type match with Addition protocol\n\ndef check() -> None:\n    expr = process(Addition(), IntegerNamedSymbol(), 42)\n    assert isinstance(expr, Addition)  # This checks structural compatibility",
    "tweak_description": "I introduced an `Addition` Protocol instead of using a raw type directly and added a method `operation` returning a `Literal` value. The `process` function\u2019s return value was explicitly annotated to match with the `Addition` Protocol. Additionally, I added an `isinstance` check to simulate further type compatibility, potentially creating divergence in how type checkers validate Protocol compliance and narrowing compatibility.",
    "checker_outputs": {
      "mypy": "/tmp/tmp3zs3rtp2.py:14: error: Cannot instantiate protocol class \"Addition\"  [misc]\n/tmp/tmp3zs3rtp2.py:15: error: Only @runtime_checkable protocols can be used with instance and class checks  [misc]\nFound 2 errors in 1 file (checked 1 source file)\n",
      "pyrefly": "ERROR Function declared to return `Literal[False]` but is missing an explicit `return` [bad-return]\n --> /tmp/tmpn1m4_izm.py:4:28\n  |\n4 |     def operation(self) -> Literal[False]:\n  |                            ^^^^^^^^^^^^^^\n  |\nERROR Cannot instantiate `Addition` because it is a protocol [bad-instantiation]\n  --> /tmp/tmpn1m4_izm.py:14:28\n   |\n14 |     expr = process(Addition(), IntegerNamedSymbol(), 42)\n   |                            ^^\n   |\nERROR Protocol `Addition` is not decorated with @runtime_checkable and cannot be used with isinstance() [invalid-argument]\n  --> /tmp/tmpn1m4_izm.py:15:29\n   |\n15 |     assert isinstance(expr, Addition)  # This checks structural compatibility\n   |                             ^^^^^^^^\n   |\n INFO 3 errors\n",
      "ty": "error[call-non-callable]: Cannot instantiate class `Addition`\n  --> /tmp/tmppum4_pyx.py:14:20\n   |\n13 | def check() -> None:\n14 |     expr = process(Addition(), IntegerNamedSymbol(), 42)\n   |                    ^^^^^^^^^^ This call will raise `TypeError` at runtime\n15 |     assert isinstance(expr, Addition)  # This checks structural compatibility\n   |\ninfo: Protocol classes cannot be instantiated\n --> /tmp/tmppum4_pyx.py:3:7\n  |\n1 | from typing import Literal, Protocol\n2 |\n3 | class Addition(Protocol):\n  |       ^^^^^^^^^^^^^^^^^^ `Addition` declared as a protocol here\n4 |     def operation(self) -> Literal[False]:\n5 |         pass\n  |\ninfo: rule `call-non-callable` is enabled by default\n\nerror[invalid-argument-type]: Class `Addition` cannot be used as the second argument to `isinstance`\n  --> /tmp/tmppum4_pyx.py:15:12\n   |\n13 | def check() -> None:\n14 |     expr = process(Addition(), IntegerNamedSymbol(), 42)\n15 |     assert isinstance(expr, Addition)  # This checks structural compatibility\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ This call will raise `TypeError` at runtime\n   |\ninfo: `Addition` is declared as a protocol class, but it is not declared as runtime-checkable\n --> /tmp/tmppum4_pyx.py:3:7\n  |\n1 | from typing import Literal, Protocol\n2 |\n3 | class Addition(Protocol):\n  |       ^^^^^^^^^^^^^^^^^^ `Addition` declared here\n4 |     def operation(self) -> Literal[False]:\n5 |         pass\n  |\ninfo: A protocol class can only be used in `isinstance` checks if it is decorated with `@typing.runtime_checkable` or `@typing_extensions.runtime_checkable`\ninfo: See https://docs.python.org/3/library/typing.html#typing.runtime_checkable\ninfo: rule `invalid-argument-type` is enabled by default\n\nFound 2 diagnostics\n",
      "zuban": "No Python files found to check for /tmp/tmpwd3nnp1c.py\n"
    },
    "checker_classifications": {
      "mypy": "ERROR",
      "pyrefly": "ERROR",
      "ty": "ERROR",
      "zuban": "CLEAN"
    },
    "analysis": "DIVERGENCE: ['mypy', 'pyrefly', 'ty'] error, ['zuban'] pass",
    "rounds": 1
  },
  {
    "id": "astral-sh-ty-1241-original",
    "source_issue": "https://github.com/astral-sh/ty/issues/1241",
    "source_issue_tracker": "https://github.com/astral-sh/ty/issues",
    "original_code": "import enum\n\nclass A(str, enum.Enum):\n    X = enum.auto()\n    Y = enum.auto()\n\nreveal_type(A.X.value)  # ty: Literal[1]; runtime value: `\"1\"`. We should probably either infer `str` or `Any`?\n\nclass B(bytes, enum.Enum):\n    X = enum.auto()\n    Y = enum.auto()\n\nreveal_type(B.X.value)  # ty: Literal[1]; runtime value: `b'\\x00'`. We should probably either infer `bytes` or `Any`?\n\nclass C(enum.Enum):\n    X = enum.auto()\n\nreveal_type(C.X.value)  # ty: Any; runtime value: `1`. We should probably infer `Literal[1]`?",
    "tweaked_code": "import enum\n\nclass A(str, enum.Enum):\n    X = enum.auto()\n    Y = enum.auto()\n\nreveal_type(A.X.value)  # ty: Literal[1]; runtime value: `\"1\"`. We should probably either infer `str` or `Any`?\n\nclass B(bytes, enum.Enum):\n    X = enum.auto()\n    Y = enum.auto()\n\nreveal_type(B.X.value)  # ty: Literal[1]; runtime value: `b'\\x00'`. We should probably either infer `bytes` or `Any`?\n\nclass C(enum.Enum):\n    X = enum.auto()\n\nreveal_type(C.X.value)  # ty: Any; runtime value: `1`. We should probably infer `Literal[1]`?",
    "tweak_description": "Original code from issue (no tweaking needed)",
    "checker_outputs": {
      "mypy": "/tmp/tmpcwjtcu72.py:7: note: Revealed type is \"builtins.int\"\n/tmp/tmpcwjtcu72.py:13: note: Revealed type is \"builtins.int\"\n/tmp/tmpcwjtcu72.py:18: note: Revealed type is \"builtins.int\"\nSuccess: no issues found in 1 source file\n",
      "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n --> /tmp/tmpildh6bh9.py:7:1\n  |\n7 | reveal_type(A.X.value)  # ty: Literal[1]; runtime value: `\"1\"`. We should probably either infer `str` or `Any`?\n  | ^^^^^^^^^^^\n  |\n INFO revealed type: str [reveal-type]\n --> /tmp/tmpildh6bh9.py:7:12\n  |\n7 | reveal_type(A.X.value)  # ty: Literal[1]; runtime value: `\"1\"`. We should probably either infer `str` or `Any`?\n  |            -----------\n  |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> /tmp/tmpildh6bh9.py:13:1\n   |\n13 | reveal_type(B.X.value)  # ty: Literal[1]; runtime value: `b'\\x00'`. We should probably either infer `bytes` or `Any`?\n   | ^^^^^^^^^^^\n   |\n INFO revealed type: bytes [reveal-type]\n  --> /tmp/tmpildh6bh9.py:13:12\n   |\n13 | reveal_type(B.X.value)  # ty: Literal[1]; runtime value: `b'\\x00'`. We should probably either infer `bytes` or `Any`?\n   |            -----------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> /tmp/tmpildh6bh9.py:18:1\n   |\n18 | reveal_type(C.X.value)  # ty: Any; runtime value: `1`. We should probably infer `Literal[1]`?\n   | ^^^^^^^^^^^\n   |\n INFO revealed type: int [reveal-type]\n  --> /tmp/tmpildh6bh9.py:18:12\n   |\n18 | reveal_type(C.X.value)  # ty: Any; runtime value: `1`. We should probably infer `Literal[1]`?\n   |            -----------\n   |\n INFO 3 errors\n",
      "ty": "warning[undefined-reveal]: `reveal_type` used without importing it\n --> /tmp/tmp70s_c5y7.py:7:1\n  |\n5 |     Y = enum.auto()\n6 |\n7 | reveal_type(A.X.value)  # ty: Literal[1]; runtime value: `\"1\"`. We should probably either infer `str` or `Any`?\n  | ^^^^^^^^^^^\n8 |\n9 | class B(bytes, enum.Enum):\n  |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n --> /tmp/tmp70s_c5y7.py:7:13\n  |\n5 |     Y = enum.auto()\n6 |\n7 | reveal_type(A.X.value)  # ty: Literal[1]; runtime value: `\"1\"`. We should probably either infer `str` or `Any`?\n  |             ^^^^^^^^^ `Literal[1]`\n8 |\n9 | class B(bytes, enum.Enum):\n  |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> /tmp/tmp70s_c5y7.py:13:1\n   |\n11 |     Y = enum.auto()\n12 |\n13 | reveal_type(B.X.value)  # ty: Literal[1]; runtime value: `b'\\x00'`. We should probably either infer `bytes` or `Any`?\n   | ^^^^^^^^^^^\n14 |\n15 | class C(enum.Enum):\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> /tmp/tmp70s_c5y7.py:13:13\n   |\n11 |     Y = enum.auto()\n12 |\n13 | reveal_type(B.X.value)  # ty: Literal[1]; runtime value: `b'\\x00'`. We should probably either infer `bytes` or `Any`?\n   |             ^^^^^^^^^ `Literal[1]`\n14 |\n15 | class C(enum.Enum):\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> /tmp/tmp70s_c5y7.py:18:1\n   |\n16 |     X = enum.auto()\n17 |\n18 | reveal_type(C.X.value)  # ty: Any; runtime value: `1`. We should probably infer `Literal[1]`?\n   | ^^^^^^^^^^^\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> /tmp/tmp70s_c5y7.py:18:13\n   |\n16 |     X = enum.auto()\n17 |\n18 | reveal_type(C.X.value)  # ty: Any; runtime value: `1`. We should probably infer `Literal[1]`?\n   |             ^^^^^^^^^ `Any`\n   |\n\nFound 6 diagnostics\n",
      "zuban": "No Python files found to check for /tmp/tmp7ek5vb4r.py\n"
    },
    "checker_classifications": {
      "mypy": "CLEAN",
      "pyrefly": "ERROR",
      "ty": "WARNING",
      "zuban": "CLEAN"
    },
    "analysis": "DIVERGENCE: ['pyrefly'] error, ['mypy', 'ty', 'zuban'] pass",
    "rounds": 0
  },
  {
    "id": "zubanls-zuban-78",
    "source_issue": "https://github.com/zubanls/zuban/issues/78",
    "source_issue_tracker": "https://github.com/zubanls/zuban/issues",
    "original_code": "thread 'main' (293604) panicked at crates/zuban_python/src/file/type_computation/mod.rs:3586:21:\ninternal error: entered unreachable code: Expected a calculated TypeVarLike in TypeParam",
    "tweaked_code": "from typing import TypeVar, Sequence, Protocol\n\nclass MyProtocol(Protocol):\n    def compute(self, value: int) -> int: ...\n\nT = TypeVar(\"T\", bound=MyProtocol)\n\ndef process_items(items: Sequence[T]) -> int:\n    result = 0\n    for item in items:\n        result += item.compute(result)  # Calls compute method defined in the protocol\n    return result\n\nclass MyConcreteClass:\n    def compute(self, value: int) -> str:  # Return type diverges from Protocol\n        return str(value)\n\n# This should create divergence on whether MyConcreteClass satisfies MyProtocol\nitems = [MyConcreteClass()]\nresult = process_items(items)\nprint(result)",
    "tweak_description": "1. I drafted plausible Python code using a `Protocol` to align with \"TypeVarLike\" and added a bound `TypeVar` (`T = TypeVar(\"T\", bound=MyProtocol)`).",
    "checker_outputs": {
      "mypy": "/tmp/tmp3qc0uzrt.py:20: error: Value of type variable \"T\" of \"process_items\" cannot be \"MyConcreteClass\"  [type-var]\nFound 1 error in 1 file (checked 1 source file)\n",
      "pyrefly": " INFO 0 errors\n",
      "ty": "error[invalid-argument-type]: Argument to function `process_items` is incorrect\n  --> /tmp/tmpd5o22_zh.py:20:24\n   |\n18 | # This should create divergence on whether MyConcreteClass satisfies MyProtocol\n19 | items = [MyConcreteClass()]\n20 | result = process_items(items)\n   |                        ^^^^^ Argument type `Unknown | MyConcreteClass` does not satisfy upper bound `MyProtocol` of type variable `T`\n21 | print(result)\n   |\ninfo: Type variable defined here\n --> /tmp/tmpd5o22_zh.py:6:1\n  |\n4 |     def compute(self, value: int) -> int: ...\n5 |\n6 | T = TypeVar(\"T\", bound=MyProtocol)\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n7 |\n8 | def process_items(items: Sequence[T]) -> int:\n  |\ninfo: rule `invalid-argument-type` is enabled by default\n\nFound 1 diagnostic\n",
      "zuban": "No Python files found to check for /tmp/tmpx9rp58r3.py\n"
    },
    "checker_classifications": {
      "mypy": "ERROR",
      "pyrefly": "ERROR",
      "ty": "ERROR",
      "zuban": "CLEAN"
    },
    "analysis": "DIVERGENCE: ['mypy', 'pyrefly', 'ty'] error, ['zuban'] pass",
    "rounds": 1
  },
  {
    "id": "astral-sh-ty-591-original",
    "source_issue": "https://github.com/astral-sh/ty/issues/591",
    "source_issue_tracker": "https://github.com/astral-sh/ty/issues",
    "original_code": "from typing import (\n    Callable,\n    Hashable,\n    Mapping,\n    TypeAlias,\n)\n\nAggFuncTypeBase: TypeAlias = Callable | str\nAggFuncTypeDictSeries: TypeAlias = Mapping[Hashable, AggFuncTypeBase]",
    "tweaked_code": "from typing import (\n    Callable,\n    Hashable,\n    Mapping,\n    TypeAlias,\n)\n\nAggFuncTypeBase: TypeAlias = Callable | str\nAggFuncTypeDictSeries: TypeAlias = Mapping[Hashable, AggFuncTypeBase]",
    "tweak_description": "Original code from issue (no tweaking needed)",
    "checker_outputs": {
      "mypy": "/tmp/tmpo2c2zvco.py:1: error: Module \"typing\" has no attribute \"TypeAlias\"  [attr-defined]\n/tmp/tmpo2c2zvco.py:1: note: Use `from typing_extensions import TypeAlias` instead\n/tmp/tmpo2c2zvco.py:1: note: See https://mypy.readthedocs.io/en/stable/runtime_troubles.html#using-new-additions-to-the-typing-module\n/tmp/tmpo2c2zvco.py:8: error: Unsupported left operand type for | (\"<typing special form>\")  [operator]\nFound 2 errors in 1 file (checked 1 source file)\n",
      "pyrefly": " INFO 0 errors\n",
      "ty": "error[unresolved-import]: Module `typing` has no member `TypeAlias`\n --> /tmp/tmp78jmq4wq.py:5:5\n  |\n3 |     Hashable,\n4 |     Mapping,\n5 |     TypeAlias,\n  |     ^^^^^^^^^\n6 | )\n  |\ninfo: rule `unresolved-import` is enabled by default\n\nerror[unsupported-operator]: Operator `|` is unsupported between objects of type `typing.Callable` and `<class 'str'>`\n --> /tmp/tmp78jmq4wq.py:8:30\n  |\n6 | )\n7 |\n8 | AggFuncTypeBase: TypeAlias = Callable | str\n  |                              ^^^^^^^^^^^^^^\n9 | AggFuncTypeDictSeries: TypeAlias = Mapping[Hashable, AggFuncTypeBase]\n  |\ninfo: Note that `X | Y` PEP 604 union syntax is only available in Python 3.10 and later\ninfo: Python 3.9 was assumed when resolving types\n --> /home/benedek-kaibas/Documents/pytifex/pyproject.toml:6:19\n  |\n4 | description = \"All the required packages you need to be able to run pytifex.\"\n5 | readme = \"README.md\"\n6 | requires-python = \">=3.9\"\n  |                   ^^^^^^^ Python 3.9 assumed due to this configuration setting\n7 | license = {text = \"MIT\"}\n8 | authors = [\n  |\ninfo: rule `unsupported-operator` is enabled by default\n\nFound 2 diagnostics\n",
      "zuban": "No Python files found to check for /tmp/tmpixkd25zy.py\n"
    },
    "checker_classifications": {
      "mypy": "ERROR",
      "pyrefly": "ERROR",
      "ty": "ERROR",
      "zuban": "CLEAN"
    },
    "analysis": "DIVERGENCE: ['mypy', 'pyrefly', 'ty'] error, ['zuban'] pass",
    "rounds": 0
  },
  {
    "id": "astral-sh-ty-851-original",
    "source_issue": "https://github.com/astral-sh/ty/issues/851",
    "source_issue_tracker": "https://github.com/astral-sh/ty/issues",
    "original_code": "import pandas as pd\n\n\ndef filter_data(data: pd.DataFrame) -> pd.DataFrame:\n    return data[(data[\"a\"] == 1)]\n\n\ndata = pd.DataFrame(\n    {\n        \"a\": [1, 2, 3, 4],\n        \"b\": [4, 3, 2, 1],\n    }\n)\n\nprint(filter_data(data))",
    "tweaked_code": "import pandas as pd\n\n\ndef filter_data(data: pd.DataFrame) -> pd.DataFrame:\n    return data[(data[\"a\"] == 1)]\n\n\ndata = pd.DataFrame(\n    {\n        \"a\": [1, 2, 3, 4],\n        \"b\": [4, 3, 2, 1],\n    }\n)\n\nprint(filter_data(data))",
    "tweak_description": "Original code from issue (no tweaking needed)",
    "checker_outputs": {
      "mypy": "/tmp/tmpiyf3y1qq.py:1: error: Library stubs not installed for \"pandas\"  [import-untyped]\n/tmp/tmpiyf3y1qq.py:1: note: Hint: \"python3 -m pip install pandas-stubs\"\n/tmp/tmpiyf3y1qq.py:1: note: (or run \"mypy --install-types\" to install all missing stub packages)\n/tmp/tmpiyf3y1qq.py:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports\nFound 1 error in 1 file (checked 1 source file)\n",
      "pyrefly": "ERROR Could not find import of `pandas` [missing-import]\n --> /tmp/tmprz7oxuf_.py:1:8\n  |\n1 | import pandas as pd\n  |        ^^^^^^^^^^^^\n  |\n  Looked in these locations:\n  Fallback search path (guessed from project_includes): [\"/tmp\", \"/\"]\n  Site package path queried from interpreter: [\"/home/benedek-kaibas/miniconda3/lib/python3.12\", \"/home/benedek-kaibas/miniconda3/lib/python3.12/lib-dynload\", \"/home/benedek-kaibas/.local/lib/python3.12/site-packages\", \"/home/benedek-kaibas/miniconda3/lib/python3.12/site-packages\"]\n INFO 1 error\n",
      "ty": "error[unresolved-import]: Cannot resolve imported module `pandas`\n --> /tmp/tmp498k78r8.py:1:8\n  |\n1 | import pandas as pd\n  |        ^^^^^^^^^^^^\n  |\ninfo: Searched in the following paths during module resolution:\ninfo:   1. /home/benedek-kaibas/Documents/pytifex/src (first-party code)\ninfo:   2. /home/benedek-kaibas/Documents/pytifex (first-party code)\ninfo:   3. vendored://stdlib (stdlib typeshed stubs vendored by ty)\ninfo:   4. /home/benedek-kaibas/miniconda3/lib/python3.12/site-packages (site-packages)\ninfo: make sure your Python environment is properly configured: https://docs.astral.sh/ty/modules/#python-environment\ninfo: rule `unresolved-import` is enabled by default\n\nFound 1 diagnostic\n",
      "zuban": "No Python files found to check for /tmp/tmpyoejuisz.py\n"
    },
    "checker_classifications": {
      "mypy": "ERROR",
      "pyrefly": "ERROR",
      "ty": "ERROR",
      "zuban": "CLEAN"
    },
    "analysis": "DIVERGENCE: ['mypy', 'pyrefly', 'ty'] error, ['zuban'] pass",
    "rounds": 0
  },
  {
    "id": "zubanls-zuban-97-original",
    "source_issue": "https://github.com/zubanls/zuban/issues/97",
    "source_issue_tracker": "https://github.com/zubanls/zuban/issues",
    "original_code": "import enum\nfrom dataclasses import dataclass\nfrom typing import Literal, reveal_type\n\n\nclass Color(enum.Enum):\n    red = \"red\"\n    blue = \"blue\"\n\n\nColors = Literal[\"red\", \"blue\"]\n\n\n@dataclass\nclass Foo:\n    bar: Colors\n\n\ndef test(foo: Foo, color: Color):\n    foo.bar = reveal_type(color.value)\n\n\ndef test2(color: Color) -> Colors:\n    return color.value",
    "tweaked_code": "import enum\nfrom dataclasses import dataclass\nfrom typing import Literal, reveal_type\n\n\nclass Color(enum.Enum):\n    red = \"red\"\n    blue = \"blue\"\n\n\nColors = Literal[\"red\", \"blue\"]\n\n\n@dataclass\nclass Foo:\n    bar: Colors\n\n\ndef test(foo: Foo, color: Color):\n    foo.bar = reveal_type(color.value)\n\n\ndef test2(color: Color) -> Colors:\n    return color.value",
    "tweak_description": "Original code from issue (no tweaking needed)",
    "checker_outputs": {
      "mypy": "/tmp/tmp9agslcy_.py:3: error: Module \"typing\" has no attribute \"reveal_type\"  [attr-defined]\n/tmp/tmp9agslcy_.py:3: note: Use `from typing_extensions import reveal_type` instead\n/tmp/tmp9agslcy_.py:3: note: See https://mypy.readthedocs.io/en/stable/runtime_troubles.html#using-new-additions-to-the-typing-module\n/tmp/tmp9agslcy_.py:19: error: Function is missing a return type annotation  [no-untyped-def]\nFound 2 errors in 1 file (checked 1 source file)\n",
      "pyrefly": "ERROR `str` is not assignable to attribute `bar` with type `Literal['blue', 'red']` [bad-assignment]\n  --> /tmp/tmp8pqe9_n0.py:20:15\n   |\n20 |     foo.bar = reveal_type(color.value)\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n INFO revealed type: str [reveal-type]\n  --> /tmp/tmp8pqe9_n0.py:20:26\n   |\n20 |     foo.bar = reveal_type(color.value)\n   |                          -------------\n   |\nERROR Returned type `str` is not assignable to declared return type `Literal['blue', 'red']` [bad-return]\n  --> /tmp/tmp8pqe9_n0.py:24:12\n   |\n24 |     return color.value\n   |            ^^^^^^^^^^^\n   |\n INFO 2 errors\n",
      "ty": "error[unresolved-import]: Module `typing` has no member `reveal_type`\n --> /tmp/tmp06jyifk6.py:3:29\n  |\n1 | import enum\n2 | from dataclasses import dataclass\n3 | from typing import Literal, reveal_type\n  |                             ^^^^^^^^^^^\n  |\ninfo: rule `unresolved-import` is enabled by default\n\nFound 1 diagnostic\n",
      "zuban": "No Python files found to check for /tmp/tmp2_cp_lwk.py\n"
    },
    "checker_classifications": {
      "mypy": "ERROR",
      "pyrefly": "ERROR",
      "ty": "ERROR",
      "zuban": "CLEAN"
    },
    "analysis": "DIVERGENCE: ['mypy', 'pyrefly', 'ty'] error, ['zuban'] pass",
    "rounds": 0
  },
  {
    "id": "astral-sh-ty-710-original",
    "source_issue": "https://github.com/astral-sh/ty/issues/710",
    "source_issue_tracker": "https://github.com/astral-sh/ty/issues",
    "original_code": "def outer(x: int | None):\n    if x is not None:\n        def inner():\n            reveal_type(x)  # int | None, should be int\n        \n        inner()",
    "tweaked_code": "def outer(x: int | None):\n    if x is not None:\n        def inner():\n            reveal_type(x)  # int | None, should be int\n        \n        inner()",
    "tweak_description": "Original code from issue (no tweaking needed)",
    "checker_outputs": {
      "mypy": "/tmp/tmp4r2u8laf.py:1: error: Function is missing a return type annotation  [no-untyped-def]\n/tmp/tmp4r2u8laf.py:1: error: X | Y syntax for unions requires Python 3.10  [syntax]\n/tmp/tmp4r2u8laf.py:3: error: Function is missing a return type annotation  [no-untyped-def]\n/tmp/tmp4r2u8laf.py:3: note: Use \"-> None\" if function does not return a value\n/tmp/tmp4r2u8laf.py:4: note: Revealed type is \"Any\"\n/tmp/tmp4r2u8laf.py:4: note: 'reveal_type' always outputs 'Any' in unchecked functions\nFound 3 errors in 1 file (checked 1 source file)\n",
      "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n --> /tmp/tmpunh06s68.py:4:13\n  |\n4 |             reveal_type(x)  # int | None, should be int\n  |             ^^^^^^^^^^^\n  |\n INFO revealed type: int | None [reveal-type]\n --> /tmp/tmpunh06s68.py:4:24\n  |\n4 |             reveal_type(x)  # int | None, should be int\n  |                        ---\n  |\n INFO 1 error\n",
      "ty": "warning[undefined-reveal]: `reveal_type` used without importing it\n --> /tmp/tmpadb0p9cp.py:4:13\n  |\n2 |     if x is not None:\n3 |         def inner():\n4 |             reveal_type(x)  # int | None, should be int\n  |             ^^^^^^^^^^^\n5 |         \n6 |         inner()\n  |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n --> /tmp/tmpadb0p9cp.py:4:25\n  |\n2 |     if x is not None:\n3 |         def inner():\n4 |             reveal_type(x)  # int | None, should be int\n  |                         ^ `int`\n5 |         \n6 |         inner()\n  |\n\nFound 2 diagnostics\n",
      "zuban": "No Python files found to check for /tmp/tmp9fh7lurn.py\n"
    },
    "checker_classifications": {
      "mypy": "ERROR",
      "pyrefly": "ERROR",
      "ty": "WARNING",
      "zuban": "CLEAN"
    },
    "analysis": "DIVERGENCE: ['mypy', 'pyrefly'] error, ['ty', 'zuban'] pass",
    "rounds": 0
  },
  {
    "id": "zubanls-zuban-121-original",
    "source_issue": "https://github.com/zubanls/zuban/issues/121",
    "source_issue_tracker": "https://github.com/zubanls/zuban/issues",
    "original_code": "from typing import Literal\n\nKey = Literal['a']  # error: Name \"a\" is not defined  [name-defined]\n\ndef send_key(key: Key) -> None:\n    pass",
    "tweaked_code": "from typing import Literal\n\nKey = Literal['a']  # error: Name \"a\" is not defined  [name-defined]\n\ndef send_key(key: Key) -> None:\n    pass",
    "tweak_description": "Original code from issue (no tweaking needed)",
    "checker_outputs": {
      "mypy": "Success: no issues found in 1 source file\n",
      "pyrefly": " INFO 0 errors\n",
      "ty": "All checks passed!\n",
      "zuban": "No Python files found to check for /tmp/tmpqyq92l2b.py\n"
    },
    "checker_classifications": {
      "mypy": "CLEAN",
      "pyrefly": "ERROR",
      "ty": "CLEAN",
      "zuban": "CLEAN"
    },
    "analysis": "DIVERGENCE: ['pyrefly'] error, ['mypy', 'ty', 'zuban'] pass",
    "rounds": 0
  },
  {
    "id": "zubanls-zuban-111-original",
    "source_issue": "https://github.com/zubanls/zuban/issues/111",
    "source_issue_tracker": "https://github.com/zubanls/zuban/issues",
    "original_code": "from pydantic import BaseModel\n\nclass Bar(BaseModel):\n    id: str\n    name: str | None = None\n\n\nbar_name_to_value = {\n    \"Bar 1\": 100,\n    \"Bar 2\": 200,\n}\n\nbars = [Bar(id=\"1\", name=\"Bar 1\"), Bar(id=\"2\", name=None)]\nfor bar in filter(lambda bar: bar.name, bars):\n    bar_name = bar.name\n    bar_value = bar_name_to_value.get(bar_name)",
    "tweaked_code": "from pydantic import BaseModel\n\nclass Bar(BaseModel):\n    id: str\n    name: str | None = None\n\n\nbar_name_to_value = {\n    \"Bar 1\": 100,\n    \"Bar 2\": 200,\n}\n\nbars = [Bar(id=\"1\", name=\"Bar 1\"), Bar(id=\"2\", name=None)]\nfor bar in filter(lambda bar: bar.name, bars):\n    bar_name = bar.name\n    bar_value = bar_name_to_value.get(bar_name)",
    "tweak_description": "Original code from issue (no tweaking needed)",
    "checker_outputs": {
      "mypy": "/tmp/tmphf7zk4h8.py:5: error: X | Y syntax for unions requires Python 3.10  [syntax]\n/tmp/tmphf7zk4h8.py:16: error: Argument 1 to \"get\" of \"dict\" has incompatible type \"Optional[str]\"; expected \"str\"  [arg-type]\nFound 2 errors in 1 file (checked 1 source file)\n",
      "pyrefly": " INFO 0 errors\n",
      "ty": "All checks passed!\n",
      "zuban": "No Python files found to check for /tmp/tmpp7zoct0p.py\n"
    },
    "checker_classifications": {
      "mypy": "ERROR",
      "pyrefly": "ERROR",
      "ty": "CLEAN",
      "zuban": "CLEAN"
    },
    "analysis": "DIVERGENCE: ['mypy', 'pyrefly'] error, ['ty', 'zuban'] pass",
    "rounds": 0
  }
]