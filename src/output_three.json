[
  {
    "title": "Type Checker Divergence 1",
    "description": "Code snippet demonstrating type checker divergence: protocol-default-args",
    "code": "# id: protocol-default-args\n# EXPECTED:\n#   mypy: Error (default argument mismatch)\n#   pyright: No error\n#   pyre: Error (default argument mismatch)\n#   zuban: Error (default argument mismatch)\n# REASON: Protocol default argument strictness differs\nfrom typing import Protocol\n\nclass Reader(Protocol):\n    def read(self, size: int = -1) -> bytes: ...\n\nclass CustomReader:\n    def read(self, size: int = 2048) -> bytes:\n        return b\"custom\"\n\ndef use_reader(r: Reader) -> None:\n    pass\n\nif __name__ == \"__main__\":\n    use_reader(CustomReader())  # Mismatched default value"
  },
  {
    "title": "Type Checker Divergence 2",
    "description": "Code snippet demonstrating type checker divergence: typeguard-narrowing",
    "code": "# id: typeguard-narrowing\n# EXPECTED:\n#   mypy: Error (narrowing failure)\n#   pyright: No error\n#   pyre: Error (narrowing failure)\n#   zuban: Error (narrowing failure)\n# REASON: TypeGuard narrowing behavior in generics\nfrom typing import TypeGuard, TypeVar, List\n\nT = TypeVar('T')\n\ndef is_str_list(val: list[object]) -> TypeGuard[list[str]]:\n    return all(isinstance(x, str) for x in val)\n\ndef process(data: List[object]) -> None:\n    if is_str_list(data):\n        data.append(42)  # Should be invalid for list[str]\n\nif __name__ == \"__main__\":\n    process([\"a\", \"b\"])"
  },
  {
    "title": "Type Checker Divergence 3",
    "description": "Code snippet demonstrating type checker divergence: typeddict-mixed-total",
    "code": "# id: typeddict-mixed-total\n# EXPECTED:\n#   mypy: Optional[int]\n#   pyright: int | None\n#   pyre: int\n#   zuban: int | None\n# REASON: TypedDict total inheritance handling\nfrom typing import TypedDict\nfrom typing_extensions import NotRequired\n\nclass Base(TypedDict, total=False):\n    x: int\n\nclass Child(Base, total=True):\n    y: str\n    x: NotRequired[int]  # Mixed total semantics\n\ndef test(td: Child) -> None:\n    reveal_type(td.get('x'))  # Checkers disagree on optionality\n\nif __name__ == \"__main__\":\n    test({\"y\": \"value\"})"
  },
  {
    "title": "Type Checker Divergence 4",
    "description": "Code snippet demonstrating type checker divergence: decorator-classmethod",
    "code": "# id: decorator-classmethod\n# EXPECTED:\n#   mypy: Error (signature mismatch)\n#   pyright: No error\n#   pyre: Error (signature mismatch)\n#   zuban: Error (signature mismatch)\n# REASON: Decorator signature preservation on classmethods\nfrom typing import Callable, TypeVar\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\ndef debug(func: Callable[P, R]) -> Callable[P, R]:\n    return func\n\nclass API:\n    @debug\n    @classmethod\n    def endpoint(cls, id: int) -> \"API\":  # Signature preservation\n        return cls()\n\nif __name__ == \"__main__\":\n    API.endpoint(42)"
  },
  {
    "title": "Type Checker Divergence 5",
    "description": "Code snippet demonstrating type checker divergence: self-generics",
    "code": "# id: self-generics\n# EXPECTED:\n#   mypy: Error (Self return)\n#   pyright: No error\n#   pyre: Error (Self return)\n#   zuban: Error (Self return)\n# REASON: Self type in generic abstract classes\nfrom typing import Generic, TypeVar\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass Factory(ABC, Generic[T]):\n    @abstractmethod\n    def make(self) -> Self:  # Self in generics\n        ...\n\nclass StringFactory(Factory[str]):\n    def make(self) -> Self:\n        return self\n\nif __name__ == \"__main__\":\n    StringFactory().make()"
  },
  {
    "title": "Type Checker Divergence 6",
    "description": "Code snippet demonstrating type checker divergence: newtype-covariance",
    "code": "# id: newtype-covariance\n# EXPECTED:\n#   mypy: Error (invariance)\n#   pyright: No error\n#   pyre: Error (invariance)\n#   zuban: Error (invariance)\n# REASON: NewType container variance handling\nfrom typing import NewType, List\n\nAccountId = NewType('AccountId', int)\nTransactionId = NewType('TransactionId', int)\n\ndef process_accounts(ids: List[AccountId]) -> None: ...\n\nif __name__ == \"__main__\":\n    accounts: List[AccountId] = [AccountId(1), AccountId(2)]\n    numbers: List[int] = [1, 2, 3]\n    \n    process_accounts(accounts)  # Valid\n    process_accounts(numbers)   # Checkers disagree on covariance"
  },
  {
    "title": "Type Checker Divergence 7",
    "description": "Code snippet demonstrating type checker divergence: overload-literal",
    "code": "# id: overload-literal\n# EXPECTED:\n#   mypy: bool\n#   pyright: bool\n#   pyre: bool | str\n#   zuban: bool\n# REASON: Literal discrimination in overloads\nfrom typing import overload, Literal, Union\n\n@overload\ndef convert(val: Literal[\"on\"]) -> bool: ...\n@overload\ndef convert(val: Literal[\"off\"]) -> bool: ...\n@overload\ndef convert(val: str) -> str: ...\n\ndef convert(val: str) -> Union[bool, str]:\n    if val == \"on\": return True\n    if val == \"off\": return False\n    return val\n\nif __name__ == \"__main__\":\n    reveal_type(convert(\"on\"))  # Literal discrimination"
  },
  {
    "title": "Type Checker Divergence 8",
    "description": "Code snippet demonstrating type checker divergence: final-override",
    "code": "# id: final-override\n# EXPECTED:\n#   mypy: Error (Final violation)\n#   pyright: No error\n#   pyre: Error (Final violation)\n#   zuban: Error (Final violation)\n# REASON: Final attribute override with property\nfrom typing import Final\n\nclass Base:\n    version: Final[int] = 1\n\nclass Sub(Base):\n    @property\n    def version(self) -> int:  # Override Final\n        return 2\n\nif __name__ == \"__main__\":\n    print(Sub().version)"
  },
  {
    "title": "Type Checker Divergence 9",
    "description": "Code snippet demonstrating type checker divergence: double-bound-generics",
    "code": "# id: double-bound-generics\n# EXPECTED:\n#   mypy: Error (type bound)\n#   pyright: No error\n#   pyre: Error (type bound)\n#   zuban: Error (type bound)\n# REASON: Double-bound TypeVar with generics\nfrom typing import TypeVar, Generic\n\nclass Animal: pass\nclass Mammal(Animal): pass\n\nT = TypeVar('T', bound=Animal)\n\nclass Cage(Generic[T]): pass\n\nU = TypeVar('U', bound=Cage[Animal])\n\ndef examine(cage: U) -> None: ...\n\nif __name__ == \"__main__\":\n    examine(Cage[Mammal]())  # Checkers disagree on bound compatibility"
  },
  {
    "title": "Type Checker Divergence 10",
    "description": "Code snippet demonstrating type checker divergence: callable-kwargs",
    "code": "# id: callable-kwargs\n# EXPECTED:\n#   mypy: Error (positional vs keyword)\n#   pyright: No error\n#   pyre: Error (positional vs keyword)\n#   zuban: Error (positional vs keyword)\n# REASON: Callable protocol keyword argument matching\nfrom typing import Protocol\n\nclass Handler(Protocol):\n    def __call__(self, *, user: str, token: str) -> str: ...\n\ndef auth(user: str, token: str) -> str:\n    return f\"{user}:{token}\"\n\nif __name__ == \"__main__\":\n    handler: Handler = auth  # Positional vs keyword mismatch"
  }
]