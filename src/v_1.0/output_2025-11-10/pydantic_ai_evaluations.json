[
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_0.py",
    "code": "from typing import Protocol\n\nclass Writer(Protocol):\n    def write(self, data: bytes, mode: str = 'w') -> int: ...\n\nclass FileWriter:\n    def write(self, data: bytes, mode: str = 'a') -> int:  # Different default 'a' vs 'w'\n        return len(data)\n\ndef use_writer(w: Writer) -> None: ...\nuse_writer(FileWriter())  # Checkers disagree on default arg compatibility",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "PASS",
      "reasoning": "According to PEP 544 (Protocols), structural subtyping semantics apply. A Protocol only checks if the signature matches in terms of method name, argument types, return types, and method presence; it does not require the default argument values to match. This is crucial here, as FileWriter's `write` method is compatible with Writer's protocol even though their default arguments differ.",
      "type_system_feature": "Protocol structural subtyping semantics",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "incorrect_checkers": [],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_1.py",
    "code": "from typing import TypeGuard, TypeVar, Dict, Any\nK = TypeVar('K')\nV = TypeVar('V')\n\ndef is_str_dict(val: dict[Any, Any]) -> TypeGuard[dict[str, str]]:\n    return all(isinstance(k, str) and isinstance(v, str) for k, v in val.items())\n\ndef process(data: Dict[object, object]) -> None:\n    if is_str_dict(data):\n        data['key'] = 'value'  # Checkers disagree on key/value type narrowing",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_1.py:1: error: Module \"typing\" has no attribute \"TypeGuard\"  [attr-defined]\noutput_2025-11-10/extracted_python_snippets/code_snippet_1.py:1: note: Use `from typing_extensions import TypeGuard` instead\noutput_2025-11-10/extracted_python_snippets/code_snippet_1.py:1: note: See https://mypy.readthedocs.io/en/stable/runtime_troubles.html#using-new-additions-to-the-typing-module\nFound 1 error in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "FAIL",
        "return_code": 1,
        "output": "error[unresolved-import]: Module `typing` has no member `TypeGuard`\n --> output_2025-11-10/extracted_python_snippets/code_snippet_1.py:1:20\n  |\n1 | from typing import TypeGuard, TypeVar, Dict, Any\n  |                    ^^^^^^^^^\n2 | K = TypeVar('K')\n3 | V = TypeVar('V')\n  |\ninfo: rule `unresolved-import` is enabled by default\n\nFound 1 diagnostic\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The code specifies the usage of `TypeGuard`, which was officially added to the `typing` module only in Python 3.10. If the Python version used by the type checker is below this (e.g., Python 3.9 or earlier), the code will fail due to `TypeGuard` not being found in the `typing` module, as inferred in the error messages from mypy and ty. Type checkers like pyrefly and zuban likely do not enforce strict version checks for such imports, and that is why they passed this code erroneously.",
      "type_system_feature": "TypeGuard and version compatibility",
      "correct_checkers": [
        "mypy",
        "ty"
      ],
      "incorrect_checkers": [
        "pyrefly",
        "zuban"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_10.py",
    "code": "# id: protocol-default-args-writer\n# EXPECTED:\n#   mypy: No error\n#   pyright: Error\n#   pyre: Error\n#   zuban: No error\n# REASON: Protocol parameter defaults aren't checked by all type checkers\nfrom typing import Protocol\n\nclass Writer(Protocol):\n    def write(self, data: bytes, mode: str = 'w') -> int: ...\n\nclass BufferedWriter:\n    def write(self, data: bytes, mode: str = 'wb') -> int:  # Different default\n        return len(data)\n\ndef use_writer(w: Writer) -> None: ...\n\nif __name__ == \"__main__\":\n    use_writer(BufferedWriter())  # Divergence in default arg compatibility",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The code violates the structural subtyping requirements of Protocols when used with argument defaults. Specifically, the `Writer` Protocol specifies a method `write` with a default `mode` argument of `'w'`, while the `BufferedWriter` class implements a `write` method that has a default `mode` argument of `'wb'`. This mismatch in defaults makes `BufferedWriter` incompatible with `Writer`, due to the rules of Protocol structural subtyping in PEP 544.",
      "type_system_feature": "Protocol structural subtyping of default arguments",
      "correct_checkers": [
        "pyright",
        "pyre"
      ],
      "incorrect_checkers": [
        "mypy",
        "zuban"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_11.py",
    "code": "# id: typeguard-tuple-narrow\n# EXPECTED:\n#   mypy: Item access error\n#   pyright: No error\n#   pyre: Item access error\n#   zuban: No error\n# REASON: TypeGuard narrowing for tuples handled differently\nfrom typing import TypeGuard, Union\n\ndef is_int_tuple(val: tuple[Union[int, str], ...]) -> TypeGuard[tuple[int, ...]]:\n    return all(isinstance(x, int) for x in val)\n\ndef process(data: tuple[Union[int, str], ...]) -> None:\n    if is_int_tuple(data):\n        data[0] + 1  # Checkers disagree on element type narrowing\n\nif __name__ == \"__main__\":\n    process((1, \"two\"))",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_11.py:8: error: Module \"typing\" has no attribute \"TypeGuard\"  [attr-defined]\noutput_2025-11-10/extracted_python_snippets/code_snippet_11.py:8: note: Use `from typing_extensions import TypeGuard` instead\noutput_2025-11-10/extracted_python_snippets/code_snippet_11.py:8: note: See https://mypy.readthedocs.io/en/stable/runtime_troubles.html#using-new-additions-to-the-typing-module\noutput_2025-11-10/extracted_python_snippets/code_snippet_11.py:15: error: Unsupported operand types for + (\"str\" and \"int\")  [operator]\noutput_2025-11-10/extracted_python_snippets/code_snippet_11.py:15: note: Left operand is of type \"Union[int, str]\"\nFound 2 errors in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "FAIL",
        "return_code": 1,
        "output": "error[unresolved-import]: Module `typing` has no member `TypeGuard`\n  --> output_2025-11-10/extracted_python_snippets/code_snippet_11.py:8:20\n   |\n 6 | #   zuban: No error\n 7 | # REASON: TypeGuard narrowing for tuples handled differently\n 8 | from typing import TypeGuard, Union\n   |                    ^^^^^^^^^\n 9 |\n10 | def is_int_tuple(val: tuple[Union[int, str], ...]) -> TypeGuard[tuple[int, ...]]:\n   |\ninfo: rule `unresolved-import` is enabled by default\n\nerror[unsupported-operator]: Operator `+` is unsupported between objects of type `int | str` and `Literal[1]`\n  --> output_2025-11-10/extracted_python_snippets/code_snippet_11.py:15:9\n   |\n13 | def process(data: tuple[Union[int, str], ...]) -> None:\n14 |     if is_int_tuple(data):\n15 |         data[0] + 1  # Checkers disagree on element type narrowing\n   |         ^^^^^^^^^^^\n16 |\n17 | if __name__ == \"__main__\":\n   |\ninfo: rule `unsupported-operator` is enabled by default\n\nFound 2 diagnostics\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The key issue in this snippet is that `TypeGuard` is utilized from `typing`, but that attribute does not exist in the standard library in Python versions prior to 3.10. The error messages from the type checkers highlight that `TypeGuard` is not found in `typing`. Users would need to use `from typing_extensions import TypeGuard` in environments lacking Python 3.10 or later support. \n\nAdditionally, the reasoning for why type checking should fail is supported by the fact that mypy and ty correctly identify the type narrowing behavior of `TypeGuard`, showing that it cannot work here due to import errors.\n\nTherefore, the code SHOULD FAIL type checking due to this missing import, and type checkers like mypy and ty are correct in identifying the issue.",
      "type_system_feature": "TypeGuard and type narrowing behavior",
      "correct_checkers": [
        "mypy",
        "ty"
      ],
      "incorrect_checkers": [
        "pyrefly",
        "zuban"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_12.py",
    "code": "# id: typeddict-mixed-required\n# EXPECTED:\n#   mypy: 'name' is required\n#   pyright: 'name' is optional\n#   pyre: 'name' is required\n#   zuban: 'name' is optional\n# REASON: Total inheritance semantics differ across checkers\nfrom typing import TypedDict\nfrom typing_extensions import Required, NotRequired\n\nclass Base(TypedDict, total=True):\n    id: int\n\nclass User(Base, total=False):\n    name: Required[str]\n    age: NotRequired[int]\n\ndef handle_user(u: User) -> None:\n    u['id']  # All agree required\n    u['name']  # Checkers disagree on required status\n\nif __name__ == \"__main__\":\n    handle_user({'id': 1, 'name': 'Alice'})",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "PASS",
      "reasoning": "The code creates two TypedDict classes: 'Base' where all keys are required (due to 'total=True') and 'User', which inherits from 'Base' but uses selective requiredness for its fields using 'Required' and 'NotRequired'. According to PEP 655, this is valid usage. The 'id' field should always be required (as it is inherited from the base class with 'total=True'), while 'name' is explicitly marked as 'Required'. There is no violation of the typing rules, so the program should PASS type checking.",
      "type_system_feature": "TypedDict selective requiredness (PEP 655)",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "incorrect_checkers": [],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_13.py",
    "code": "# id: decorator-classmethod-return\n# EXPECTED:\n#   mypy: Incompatible return type\n#   pyright: No error\n#   pyre: Incompatible return type\n#   zuban: No error\n# REASON: Decorator chain preservation for classmethod returns\nfrom typing import Callable, TypeVar, Any\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef validate(func: Callable[P, T]) -> Callable[P, T]:\n    return func\n\nclass Factory:\n    @validate\n    @classmethod\n    def create(cls, value: int) -> \"Factory\":  # Checkers disagree on return type\n        return cls()\n\nif __name__ == \"__main__\":\n    Factory.create(42)",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The typing feature in question deals with decorator chain preservation for class methods. When a function such as `create` is decorated with `classmethod`, it modifies its type signature: the first implicit parameter should now be the class type rather than bound to the instance type. However, when another decorator like `@validate` is applied, the type inference of some checkers might fail to preserve the correct method type signature. In this case, `validate` appears to return the input function without proper preservation of the `@classmethod` type addition. This creates an incompatible type when the method is later used. Therefore, the expected behavior is for a type checker to flag this as a failure.",
      "type_system_feature": "Decorator chain preservation for classmethod return types",
      "correct_checkers": [
        "mypy",
        "pyre"
      ],
      "incorrect_checkers": [
        "pyrefly",
        "zuban",
        "ty"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_14.py",
    "code": "# id: self-generic-inheritance\n# EXPECTED:\n#   mypy: Return type incompatible\n#   pyright: No error\n#   pyre: Incompatible return type\n#   zuban: No error\n# REASON: Self type in generic base class handling\nfrom typing import Generic, TypeVar\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass Template(ABC, Generic[T]):\n    @abstractmethod\n    def clone(self) -> Self: ...\n\nclass StringTemplate(Template[str]):\n    def clone(self) -> Self:\n        return self  # Checkers disagree on Self compatibility\n\nif __name__ == \"__main__\":\n    StringTemplate().clone()",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The code defines a generic base class `Template` with a method `clone` that is expected to return `Self`. The derived class `StringTemplate` overrides `clone` to return `self`. However, the use of `Self` in the signature is intended to indicate that the returned type must match the subclass type exactly. This means that, while the implementation of `clone` may syntactically appear correct, type checkers should raise an error because `self` may not be of the exact type `StringTemplate`. For example, if `StringTemplate` was further subclassed, `clone` would return the wrong type according to strict `Self` semantics.",
      "type_system_feature": "Self type in generic base class",
      "correct_checkers": [],
      "incorrect_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_15.py",
    "code": "# id: newtype-list-covariance\n# EXPECTED:\n#   mypy: List invariant error\n#   pyright: No error\n#   pyre: List invariant error\n#   zuban: No error\n# REASON: NewType list covariance handling differs\nfrom typing import NewType, List\n\nHandle = NewType('Handle', int)\nPort = NewType('Port', int)\n\ndef open_connections(handles: List[Handle]) -> None: ...\n\nif __name__ == \"__main__\":\n    ports: List[Port] = [Port(80), Port(443)]\n    open_connections(ports)  # Checkers disagree on NewType list compatibility",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_15.py:17: error: Argument 1 to \"open_connections\" has incompatible type \"list[Port]\"; expected \"list[Handle]\"  [arg-type]\nFound 1 error in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "FAIL",
        "return_code": 1,
        "output": "ERROR Argument `list[Port]` is not assignable to parameter `handles` with type `list[Handle]` in function `open_connections` [bad-argument-type]\n  --> output_2025-11-10/extracted_python_snippets/code_snippet_15.py:17:22\n   |\n17 |     open_connections(ports)  # Checkers disagree on NewType list compatibility\n   |                      ^^^^^\n   |\n INFO 1 error\n"
      },
      {
        "checker_name": "zuban",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_15.py:17: error: Argument 1 to \"open_connections\" has incompatible type \"list[Port]\"; expected \"list[Handle]\"  [arg-type]\nFound 1 error in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The code demonstrates a type mismatch due to Python's type rules regarding invariance of generic classes such as List. NewType creates nominal types (not structural types), meaning each NewType is considered completely independent. Therefore, a List[Port] is not compatible with a List[Handle], even though both NewTypes are based on the same underlying type (int). Most type checkers recognize List's invariance, raising errors when trying to pass a List[Port] where a List[Handle] is expected.",
      "type_system_feature": "List invariance with NewType",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban"
      ],
      "incorrect_checkers": [
        "ty"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_16.py",
    "code": "# id: overload-literal-int\n# EXPECTED:\n#   mypy: Incompatible return type\n#   pyright: Literal type preserved\n#   pyre: Incompatible return type\n#   zuban: Literal type preserved\n# REASON: Literal type narrowing in overload resolution\nfrom typing import overload, Literal, Union\n\n@overload\ndef parse_int(value: Literal[\"0\"]) -> Literal[0]: ...\n@overload\ndef parse_int(value: str) -> Union[int, None]: ...\n\ndef parse_int(value: str) -> Union[int, None]:\n    try: return int(value)\n    except: return None\n\nresult = parse_int(\"0\")  # Checkers disagree on Literal[0] vs int\n\nif __name__ == \"__main__\":\n    print(result)",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The code uses overloads with literal types and expects type narrowing. However, the implementation of 'parse_int' does not preserve the literal return type 'Literal[0]' when passed the literal argument '\"0\"'. Instead, it always returns an 'int' or 'None', which contradicts the explicitly overloaded signature. This mismatch between the overloaded function signatures and the implementation causes this code to fail type-checking according to strict typing standards.",
      "type_system_feature": "Literal type narrowing with overloads",
      "correct_checkers": [],
      "incorrect_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_17.py",
    "code": "# id: final-method-override\n# EXPECTED:\n#   mypy: Cannot override final method\n#   pyright: No error\n#   pyre: Cannot override final method\n#   zuban: No error\n# REASON: Final method override checking strictness\nfrom typing import final\n\nclass Base:\n    @final\n    def critical(self) -> None: ...\n\nclass Derived(Base):\n    def critical(self) -> None:  # Checkers disagree on final enforcement\n        print(\"Overridden\")\n\nif __name__ == \"__main__\":\n    Derived().critical()",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_17.py:15: error: Cannot override final attribute \"critical\" (previously declared in base class \"Base\")  [misc]\nFound 1 error in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "FAIL",
        "return_code": 1,
        "output": "ERROR `critical` is declared as final in parent class `Base` [bad-override]\n  --> output_2025-11-10/extracted_python_snippets/code_snippet_17.py:15:9\n   |\n15 |     def critical(self) -> None:  # Checkers disagree on final enforcement\n   |         ^^^^^^^^\n   |\n INFO 1 error\n"
      },
      {
        "checker_name": "zuban",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_17.py:15: error: Cannot override final attribute \"critical\" (previously declared in base class \"Base\")  [misc]\nFound 1 error in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The `@final` decorator in the `typing` module explicitly marks the `critical` method in the `Base` class as final, meaning that it cannot be overridden in subclasses such as `Derived`. This is part of the Final behavior introduced in PEP 591. Type checkers should enforce this restriction and report an error if a final method is overridden.",
      "type_system_feature": "Final and override semantics",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban"
      ],
      "incorrect_checkers": [
        "ty"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_18.py",
    "code": "# id: double-bound-generic\n# EXPECTED:\n#   mypy: Type argument error\n#   pyright: No error\n#   pyre: Type argument error\n#   zuban: No error\n# REASON: Nested generic bounds checking\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T', bound=float)\nU = TypeVar('U', bound=Generic[T])\n\nclass Container(Generic[T]): ...\n\ndef process(container: U) -> None: ...\n\nif __name__ == \"__main__\":\n    process(Container[float]())  # Checkers disagree on double-bound compatibility",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_18.py:11: error: Variable \"typing.Generic\" is not valid as a type  [valid-type]\noutput_2025-11-10/extracted_python_snippets/code_snippet_18.py:11: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases\noutput_2025-11-10/extracted_python_snippets/code_snippet_18.py:11: error: Type variable \"code_snippet_18.T\" is unbound  [valid-type]\noutput_2025-11-10/extracted_python_snippets/code_snippet_18.py:11: note: (Hint: Use \"Generic[T]\" or \"Protocol[T]\" base class to bind \"T\" inside a class)\noutput_2025-11-10/extracted_python_snippets/code_snippet_18.py:11: note: (Hint: Use \"T\" in function signature to bind \"T\" inside a function)\nFound 2 errors in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "FAIL",
        "return_code": 1,
        "output": "ERROR `Generic` is not allowed in this context [invalid-annotation]\n  --> output_2025-11-10/extracted_python_snippets/code_snippet_18.py:11:24\n   |\n11 | U = TypeVar('U', bound=Generic[T])\n   |                        ^^^^^^^^^^\n   |\n INFO 1 error\n"
      },
      {
        "checker_name": "zuban",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_18.py:11: error: Invalid type  [valid-type]\nFound 1 error in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "ty",
        "status": "FAIL",
        "return_code": 1,
        "output": "error[invalid-type-form]: `typing.Generic` is not allowed in type expressions\n  --> output_2025-11-10/extracted_python_snippets/code_snippet_18.py:11:24\n   |\n10 | T = TypeVar('T', bound=float)\n11 | U = TypeVar('U', bound=Generic[T])\n   |                        ^^^^^^^^^^\n12 |\n13 | class Container(Generic[T]): ...\n   |\ninfo: rule `invalid-type-form` is enabled by default\n\nFound 1 diagnostic\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The error across all type checkers relates to the invalid use of `Generic` within the bound of the `TypeVar`. According to PEP 484 and related typing extensions, `Generic` is intended as a class used for parameterizing other types, but it can't be directly used as part of a `TypeVar` bound. This is because `Generic[T]` itself isn't a valid type but a mechanism used for defining generic classes. Hence, all the type checkers correctly identify this misuse as an error.",
      "type_system_feature": "Nested generic bounds checking",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "incorrect_checkers": [],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_19.py",
    "code": "# id: protocol-keyword-args\n# EXPECTED:\n#   mypy: Incompatible types\n#   pyright: No error\n#   pyre: Incompatible types\n#   zuban: No error\n# REASON: Positional vs keyword argument protocol matching\nfrom typing import Protocol\n\nclass Formatter(Protocol):\n    def format(self, *, text: str, width: int) -> str: ...\n\ndef simple_format(text: str, width: int) -> str:\n    return f\"{text:{width}}\"\n\nhandler: Formatter = simple_format  # Checkers disagree on positional params\n\nif __name__ == \"__main__\":\n    handler.format(text=\"test\", width=10)",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_19.py:16: error: Incompatible types in assignment (expression has type \"Callable[[str, int], str]\", variable has type \"Formatter\")  [assignment]\nFound 1 error in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "FAIL",
        "return_code": 1,
        "output": "ERROR `(text: str, width: int) -> str` is not assignable to `Formatter` [bad-assignment]\n  --> output_2025-11-10/extracted_python_snippets/code_snippet_19.py:16:22\n   |\n16 | handler: Formatter = simple_format  # Checkers disagree on positional params\n   |                      ^^^^^^^^^^^^^\n   |\n  Protocol `Formatter` requires attribute `format`\n INFO 1 error\n"
      },
      {
        "checker_name": "zuban",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_19.py:16: error: Incompatible types in assignment (expression has type \"Callable[[str, int], str]\", variable has type \"Formatter\")  [assignment]\nFound 1 error in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "ty",
        "status": "FAIL",
        "return_code": 1,
        "output": "error[invalid-assignment]: Object of type `def simple_format(text: str, width: int) -> str` is not assignable to `Formatter`\n  --> output_2025-11-10/extracted_python_snippets/code_snippet_19.py:16:1\n   |\n14 |     return f\"{text:{width}}\"\n15 |\n16 | handler: Formatter = simple_format  # Checkers disagree on positional params\n   | ^^^^^^^\n17 |\n18 | if __name__ == \"__main__\":\n   |\ninfo: rule `invalid-assignment` is enabled by default\n\nFound 1 diagnostic\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The signature ``def format(self, *, text: str, width: int) -> str`` in the protocol explicitly requires keyword arguments (`*` ensures arguments are passed as keywords). The function ``simple_format(text: str, width: int) -> str`` accepts arguments positionally, thus violating the required protocol for method shape defined in ``Formatter``. Assigning ``simple_format`` to ``handler`` rejects structural subtyping, which means it cannot conform to ``Formatter``.",
      "type_system_feature": "Protocol structural subtyping semantics",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "incorrect_checkers": [],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_2.py",
    "code": "from typing import TypedDict\nfrom typing_extensions import NotRequired\n\nclass Parent(TypedDict, total=True):\n    a: int\n    b: NotRequired[str]\n\nclass Child(Parent, total=False):\n    c: float  # Now 'a' is required, 'b' is not, 'c' is not required\n\ndef test(td: Child) -> None:\n    td['a']  # Checkers disagree on required status of 'a' in Child",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "PASS",
      "reasoning": "The code uses the `NotRequired` marker from `typing_extensions` alongside the `TypedDict` feature. A `Parent` class is defined with one required field (`a`) and one optional field (`b`). The `Child` class inherits from `Parent` with `total=False`, meaning all newly added keys (`c` in this case) are optional by default. Importantly, inheriting from `Parent` does not alter the required/optional status of the keys defined in `Parent`. Consequently, `a` remains required, and `b` remains optional in `Child`. Since `test(td['a'])` is accessing a required field, it is valid, and thus all type checkers should pass the code without errors.",
      "type_system_feature": "TypedDict inheritance with NotRequired fields",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "incorrect_checkers": [],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_3.py",
    "code": "from typing import Callable, TypeVar, Any\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef debug(func: Callable[P, T]) -> Callable[P, T]:\n    return func\n\nclass Logger:\n    @debug\n    @classmethod\n    def log(cls, message: str) -> None:  # Checkers disagree on decorated classmethod type\n        print(message)\n\nLogger.log(\"test\")  # Some checkers may complain about 'cls' argument",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "PASS",
      "reasoning": "This code should pass type checking. It uses ParamSpec (a typing feature introduced via typing_extensions) to represent callable signature compatibility. The `debug` function explicitly forwards the callable signature it receives to its return value, ensuring that decorated functions maintain their signature. Furthermore, the combination of `classmethod` and decorator `@debug` is correctly handled, as the `cls` parameter remains the first argument of the class method no matter how it is decorated.",
      "type_system_feature": "ParamSpec decorators with classmethod",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "incorrect_checkers": [],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_4.py",
    "code": "from typing import Generic, TypeVar\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass Builder(ABC, Generic[T]):\n    @abstractmethod\n    def build(self) -> Self: ...\n\nclass IntBuilder(Builder[int]):\n    def build(self) -> Self:\n        return self  # Checkers disagree on return type compatibility",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The code returns 'self' in the 'IntBuilder.build' method while the annotation specifies 'Self', which refers to the instance type of the current class. 'Builder[int]' declares a generic interface with 'Self' as the return type, meaning it should return an instance of the same type (IntBuilder in this specific case). However, 'Self' compatibility requires tighter constraints in type checkers, and some incorrectly allow this generic mismatch.",
      "type_system_feature": "Self compatibility & return type constraints",
      "correct_checkers": [],
      "incorrect_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_5.py",
    "code": "from typing import NewType, List\n\nAccountID = NewType('AccountID', int)\nTransactionID = NewType('TransactionID', int)\n\ndef process_accounts(ids: List[AccountID]) -> None: ...\n\nmixed_list: List[int] = [AccountID(100), 200]  # Contains both AccountID and int\nprocess_accounts(mixed_list)  # Checkers disagree on List[AccountID] vs List[int]",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_5.py:9: error: Argument 1 to \"process_accounts\" has incompatible type \"list[int]\"; expected \"list[AccountID]\"  [arg-type]\nFound 1 error in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "FAIL",
        "return_code": 1,
        "output": "ERROR Argument `list[int]` is not assignable to parameter `ids` with type `list[AccountID]` in function `process_accounts` [bad-argument-type]\n --> output_2025-11-10/extracted_python_snippets/code_snippet_5.py:9:18\n  |\n9 | process_accounts(mixed_list)  # Checkers disagree on List[AccountID] vs List[int]\n  |                  ^^^^^^^^^^\n  |\n INFO 1 error\n"
      },
      {
        "checker_name": "zuban",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_5.py:9: error: Argument 1 to \"process_accounts\" has incompatible type \"list[int]\"; expected \"list[AccountID]\"  [arg-type]\nFound 1 error in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The code creates a type alias using `NewType` for `AccountID` and `TransactionID`, both based on `int`. The function `process_accounts` explicitly requires a `List[AccountID]`. However, the argument passed (`mixed_list`) contains both `AccountID` and raw integers. Despite both being nominally based on `int`, the NewType mechanism explicitly creates distinct nominal types that must match the specified type exactly, even in containers, respecting Python's typing standards. Thus, `List[int]` is not equivalent to `List[AccountID]` and should fail type checking. Type checkers like mypy, pyrefly, and zuban correctly enforce the requirement, while ty incorrectly allows this as a pass.",
      "type_system_feature": "NewType nominal typing semantics",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban"
      ],
      "incorrect_checkers": [
        "ty"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_6.py",
    "code": "from typing import overload, Literal, Union\n\n@overload\ndef convert(val: Literal[1]) -> str: ...\n@overload\ndef convert(val: Literal[2]) -> int: ...\n@overload\ndef convert(val: int) -> float: ...\n\ndef convert(val: int) -> Union[str, int, float]:\n    if val == 1:\n        return \"one\"\n    elif val == 2:\n        return 2\n    return float(val)\n\nresult = convert(1)  # Checkers disagree: str vs Union[...]",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_6.py:4: error: Overloaded function signatures 1 and 3 overlap with incompatible return types  [overload-overlap]\noutput_2025-11-10/extracted_python_snippets/code_snippet_6.py:6: error: Overloaded function signatures 2 and 3 overlap with incompatible return types  [overload-overlap]\nFound 2 errors in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The given code snippet uses overloads along with Literal types to specify different return types based on the input value. However, overloaded signatures must follow specific rules regarding non-overlapping and compatible return types. Here, the third signature `def convert(val: int) -> float` overlaps with the first (`def convert(val: Literal[1]) -> str`) and second (`def convert(val: Literal[2]) -> int`) signatures. According to PEP 484 and Python typing standards, such overlapping signatures with conflicting return types result in a type-checking error.",
      "type_system_feature": "Overload resolution rules",
      "correct_checkers": [
        "mypy"
      ],
      "incorrect_checkers": [
        "pyrefly",
        "zuban",
        "ty"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_7.py",
    "code": "from typing import Final\n\nclass Base:\n    @property\n    def value(self) -> int:\n        return 42\n\nclass Derived(Base):\n    value: Final[int] = 100  # Checkers disagree on overriding property with attribute",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The code introduces a type mismatch related to the 'Final' typing which specifies that `Derived.value` cannot be overridden and must remain constant. The Derived class redefines `value` from an inherited property in `Base` to an attribute marked as `Final[int]`. Python typing semantic rules define that overriding a method or property from a base class has to maintain invariance in type compatibility. Replacing a property with an attribute constitutes a significant type mismatch. Thus, type checkers should have flagged this redefinition as invalid according to PEP 591 and property overriding rules.",
      "type_system_feature": "Final semantics and property overriding rules",
      "correct_checkers": [],
      "incorrect_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_8.py",
    "code": "from typing import TypeVar, Generic\n\nclass Box(Generic[T]):\n    pass\n\nT2 = TypeVar('T2', bound=Box[float])\n\ndef unpack(box: T2) -> None: ...\n\nfloat_box: Box[float] = Box()\nunpack(float_box)  # Checkers disagree if T2 bound is properly enforced",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_8.py:3: error: Free type variable expected in Generic[...]  [misc]\noutput_2025-11-10/extracted_python_snippets/code_snippet_8.py:3: error: Name \"T\" is not defined  [name-defined]\noutput_2025-11-10/extracted_python_snippets/code_snippet_8.py:6: error: \"Box\" expects no type arguments, but 1 given  [type-arg]\noutput_2025-11-10/extracted_python_snippets/code_snippet_8.py:10: error: \"Box\" expects no type arguments, but 1 given  [type-arg]\nFound 4 errors in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "FAIL",
        "return_code": 1,
        "output": "ERROR Could not find name `T` [unknown-name]\n --> output_2025-11-10/extracted_python_snippets/code_snippet_8.py:3:19\n  |\n3 | class Box(Generic[T]):\n  |                   ^\n  |\n INFO 1 error\n"
      },
      {
        "checker_name": "zuban",
        "status": "FAIL",
        "return_code": 1,
        "output": "output_2025-11-10/extracted_python_snippets/code_snippet_8.py:3: error: Name \"T\" is not defined  [name-defined]\noutput_2025-11-10/extracted_python_snippets/code_snippet_8.py:3: error: Free type variable expected in Generic[...]  [misc]\noutput_2025-11-10/extracted_python_snippets/code_snippet_8.py:6: error: \"Box\" expects no type arguments, but 1 given  [type-arg]\noutput_2025-11-10/extracted_python_snippets/code_snippet_8.py:10: error: \"Box\" expects no type arguments, but 1 given  [type-arg]\nFound 4 errors in 1 file (checked 1 source file)\n"
      },
      {
        "checker_name": "ty",
        "status": "FAIL",
        "return_code": 1,
        "output": "error[invalid-argument-type]: `Unknown` is not a valid argument to `Generic`\n --> output_2025-11-10/extracted_python_snippets/code_snippet_8.py:3:11\n  |\n1 | from typing import TypeVar, Generic\n2 |\n3 | class Box(Generic[T]):\n  |           ^^^^^^^\n4 |     pass\n  |\ninfo: rule `invalid-argument-type` is enabled by default\n\nerror[unresolved-reference]: Name `T` used when not defined\n --> output_2025-11-10/extracted_python_snippets/code_snippet_8.py:3:19\n  |\n1 | from typing import TypeVar, Generic\n2 |\n3 | class Box(Generic[T]):\n  |                   ^\n4 |     pass\n  |\ninfo: rule `unresolved-reference` is enabled by default\n\nFound 2 diagnostics\n"
      }
    ],
    "analysis": {
      "correct_behavior": "FAIL",
      "reasoning": "The TypeVar 'T' is incorrectly used in the declaration of the 'Box' generic class, as its definition is missing (not imported or declared elsewhere in the code). Additionally, the TypeVar 'T2' is correctly bounded by 'Box[float]', but 'Box' itself does not support type arguments due to the prior error. Therefore, the code contains multiple issues\u2014this leads to type checkers correctly marking this as a failure.",
      "type_system_feature": "TypeVar scope and usage in generic classes",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "incorrect_checkers": [],
      "confidence": "high"
    }
  },
  {
    "filename": "output_2025-11-10/extracted_python_snippets/code_snippet_9.py",
    "code": "from typing import Protocol\n\nclass Handler(Protocol):\n    def __call__(self, *, timeout: int) -> str: ...\n\ndef handle(timeout: int) -> str:\n    return str(timeout)\n\nhandler: Handler = handle  # Checkers disagree on positional vs keyword",
    "checker_results": [
      {
        "checker_name": "mypy",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "pyrefly",
        "status": "PASS",
        "return_code": 0,
        "output": " INFO 0 errors\n"
      },
      {
        "checker_name": "zuban",
        "status": "PASS",
        "return_code": 0,
        "output": "Success: no issues found in 1 source file\n"
      },
      {
        "checker_name": "ty",
        "status": "PASS",
        "return_code": 0,
        "output": "All checks passed!\n"
      }
    ],
    "analysis": {
      "correct_behavior": "PASS",
      "reasoning": "In the code snippet, a `Protocol` named `Handler` defines a callable type that takes a keyword argument `timeout` with the type `int` and returns a `str`. The function `handle` also accepts an argument `timeout` but as a positional argument. According to PEP 544, structural subtyping applies for Protocols, meaning the similarity in function signatures is checked structurally rather than semantically binding to exact positional or keyword argument format. Since the function `handle` has the same argument type (int) and return type (str), it adheres to the structure needed by the Protocol `Handler`. The argument being positional versus keyword does not invalidate the type matching structurally. Thus, all type checkers are correct in this case, and the expected behavior is `PASS`.",
      "type_system_feature": "Protocol structural subtyping semantics",
      "correct_checkers": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
      ],
      "incorrect_checkers": [],
      "confidence": "high"
    }
  }
]